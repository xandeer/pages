<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-01-01 Sun 20:14 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Android Questions Sync with Anki</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="static/x.css" type="text/css"/><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Android Questions Sync with Anki</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org45edc9e">1. How to restart an activity?</a></li>
<li><a href="#org791f2a6">2. How to remove underline in <code>AppCompatEditText</code>?</a></li>
<li><a href="#org8c03ab4">3. How to set ellipsis for <code>EditText</code>?</a></li>
<li><a href="#orgd248acb">4. How to switch edit states of <code>EditText</code>?</a></li>
<li><a href="#org3ac02d0">5. Activity 启动模式有哪些？</a></li>
<li><a href="#org83b4da3">6. Activity 各启动模式有何差异？</a></li>
<li><a href="#org762f25e">7. <code>Activity</code> 生命周期？</a></li>
<li><a href="#orgc466980">8. <code>View</code> 事件分发机制</a></li>
<li><a href="#orgfd0beac">9. <code>ViewGroup</code> 事件分发机制</a></li>
<li><a href="#org96b55fd">10. 如何启动 <code>Service</code>?</a></li>
<li><a href="#org96a3e08">11. <code>Service</code> 生命周期？</a></li>
<li><a href="#org1db1630">12. <code>Service</code> 如何与其它组件通信？</a></li>
<li><a href="#orgbf64be2">13. Why use compose?</a></li>
<li><a href="#orgf4b5a66">14. 协程的底层原理是什么？</a></li>
<li><a href="#org91e4121">15. 为什么要用协程？</a></li>
<li><a href="#org47e1414">16. Glide 缓存机制</a></li>
<li><a href="#org2e97f4c">17. 什么是 ANR?</a></li>
<li><a href="#orgd582df3">18. 如何避免 ANR？</a></li>
<li><a href="#org76fae0a">19. 创建型设计模式有哪些？</a></li>
<li><a href="#org2bf63dd">20. 结构型设计模式有哪些？</a></li>
<li><a href="#org25dd0ea">21. 行为型设计模式有哪些？</a></li>
<li><a href="#org01dc189">22. 为何要实现 <code>equals</code> 方法？</a></li>
<li><a href="#org2b8f0d8">23. <code>hashCode</code> 有什么需要注意的？</a></li>
<li><a href="#orge09a144">24. 事件传递过程？</a></li>
<li><a href="#orga4e0a0d">25. Window, WindowManager, WMS, SurfaceFlinger</a></li>
<li><a href="#org782901a">26. <code>Handler</code>, <code>MessageQueue</code>, <code>Looper</code></a></li>
<li><a href="#org22b567a">27. IPC 方式</a></li>
<li><a href="#org8ebd4af">28. <code>Binder</code></a></li>
<li><a href="#orga4958a1">29. App 启动流程</a></li>
<li><a href="#orgdfb8a73">30. 进程保活</a></li>
<li><a href="#org4f99b4d">31. UI 卡顿优化</a></li>
<li><a href="#orgf7be4ac">32. 内存泄漏场景及规避</a></li>
<li><a href="#org0ae9cea">33. OOM 场景及规避</a></li>
<li><a href="#org96d01ea">34. <code>AIDL</code></a></li>
<li><a href="#orgd2b34c9">35. 动画</a></li>
<li><a href="#org095f187">36. <code>String</code>, <code>StringBuilder</code>, <code>StringBuffer</code> 对比</a></li>
<li><a href="#org54701cb">37. <code>ContentProvider</code></a></li>
<li><a href="#orgd2ae665">38. <code>Broadcast</code></a></li>
<li><a href="#orgca5f573">39. 如何排查内存泄漏？</a></li>
<li><a href="#org4fd729d">40. 性能监控</a></li>
<li><a href="#org2aa4c60">41. App 启动优化</a></li>
<li><a href="#orgfef352c">42. 屏幕旋转时会发生什么？</a></li>
<li><a href="#org7211c39">43. 三种 <code>Context</code></a></li>
<li><a href="#org2ca9877">44. <code>HashMap</code> 中 hash 冲突解决及扩容机制</a></li>
<li><a href="#org9c4ad05">45. 类加载机制</a>
<ul>
<li><a href="#org2a52e29">45.1. 类加载生命周期</a></li>
<li><a href="#org3a9ea32">45.2. 加载</a>
<ul>
<li><a href="#org16b2e18">45.2.1. 类加载双亲委托机制</a></li>
<li><a href="#org07b9887">45.2.2. jvm 类加载器</a></li>
<li><a href="#org43f7a9c">45.2.3. Android 类加载器</a></li>
<li><a href="#orga3ecfe7">45.2.4. jvm 与 android 类加载器区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7e5109f">46. 开源库源码及实现原理</a></li>
<li><a href="#org0a3c44a">47. LruCache 原理及实现</a></li>
<li><a href="#org237a4eb">48. 自定义 <code>View</code></a></li>
<li><a href="#orge560487">49. 怎么检测卡顿</a></li>
<li><a href="#org5771025">50. <code>Handler</code> 中 <code>post/postDelay</code> 如何实现？</a></li>
<li><a href="#org29128be">51. Kotlin 中 extension 是如何实现的？</a></li>
<li><a href="#orgb6dc954">52. 掉帧检测</a></li>
<li><a href="#org538b592">53. <code>final</code> 关键字的作用是什么？</a></li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><a href="https://juejin.cn/post/6844904079177547789">https://juejin.cn/post/6844904079177547789</a></li>
<li><a href="https://juejin.cn/user/1556564196215464/posts">https://juejin.cn/user/1556564196215464/posts</a></li>
</ul>

<div id="outline-container-org45edc9e" class="outline-2">
<h2 id="org45edc9e"><span class="section-number-2">1.</span> How to restart an activity?</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">
<pre class="src src-kotlin">// something wrong with cached view model
// recreate()

finish()
startActivity(intent)
</pre>
</div>
</div>
</div>
<div id="outline-container-org791f2a6" class="outline-2">
<h2 id="org791f2a6"><span class="section-number-2">2.</span> How to remove underline in <code>AppCompatEditText</code>?</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-kotlin">backgroundColorResource = R.color.transparent
</pre>
</div>
</div>
</div>
<div id="outline-container-org8c03ab4" class="outline-2">
<h2 id="org8c03ab4"><span class="section-number-2">3.</span> How to set ellipsis for <code>EditText</code>?</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-kotlin">ellipsize = TextUtils.TruncateAt.END
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd248acb" class="outline-2">
<h2 id="orgd248acb"><span class="section-number-2">4.</span> How to switch edit states of <code>EditText</code>?</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-kotlin">// non-editable
keyListener = null

// editable
keyListener = TextKeyListener.getInstance(false, TextKeyListener.Capitalize.NONE)
</pre>
</div>
</div>
</div>
<div id="outline-container-org3ac02d0" class="outline-2">
<h2 id="org3ac02d0"><span class="section-number-2">5.</span> Activity 启动模式有哪些？</h2>
<div class="outline-text-2" id="text-5">
<p>
Standard, SingleTop, SingleTask, SingleInstance
</p>
</div>
</div>
<div id="outline-container-org83b4da3" class="outline-2">
<h2 id="org83b4da3"><span class="section-number-2">6.</span> Activity 各启动模式有何差异？</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><code>standard</code>: 默认，启动一个就多一个 <code>Activity</code> 实例</li>
<li><code>SingleTop</code>: 栈顶复用，如果处于栈顶，则生命周期不走 <code>onCreate</code> 和 <code>onStart</code></li>
<li><code>SingleTask</code>: 栈内复用，如果存在于栈内，则在其上的 <code>Activity</code> 全部出栈，使其位于栈顶，生命周期和 <code>SingleTop</code> 一样，基本用于 app 首页</li>
<li><code>SingleInstance</code>: <code>SingleTask</code> 加强版，系统会为要启动的 <code>Activity</code> 单独开一个栈，这个栈里只有它，适用于新开 <code>Activity</code> 要和 app 能独立开的。</li>
</ul>
</div>
</div>
<div id="outline-container-org762f25e" class="outline-2">
<h2 id="org762f25e"><span class="section-number-2">7.</span> <code>Activity</code> 生命周期？</h2>
<div class="outline-text-2" id="text-7">
<p>
<code>onCreate()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code> -&gt; <code>onPause()</code> -&gt; <code>onStop()</code> -&gt; <code>onDestroy()</code>
</p>
</div>
</div>
<div id="outline-container-orgc466980" class="outline-2">
<h2 id="orgc466980"><span class="section-number-2">8.</span> <code>View</code> 事件分发机制</h2>
<div class="outline-text-2" id="text-8">
<p>
如果在 <code>onTouch</code> 的 <code>ACTION_DOWN</code> 中返回 <code>false</code>, 之后的 touch 事件将不会被触发，不影响 click 事件。
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">boolean</span> <span style="font-weight: bold;">dispatchTouchEvent</span>(<span style="font-weight: bold; text-decoration: underline;">MotionEvent</span> <span style="font-weight: bold; font-style: italic;">event</span>) {
  <span style="font-weight: bold;">if</span> (mOnTouchListener != <span style="font-weight: bold; text-decoration: underline;">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;
      mOnTouchListener.onTouch(<span style="font-weight: bold;">this</span>, event)) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>
  }
  <span style="font-weight: bold;">return</span> onTouchEvent(event)
}

<span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">boolean</span> <span style="font-weight: bold;">onTouchEvent</span>(<span style="font-weight: bold; text-decoration: underline;">MotionEvent</span> <span style="font-weight: bold; font-style: italic;">event</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
  <span style="font-weight: bold;">if</span> ((viewFlags &amp; CLICKABLE) == CLICKABLE ||
      (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
    <span style="font-weight: bold;">case</span> <span style="font-weight: bold; text-decoration: underline;">MotionEvent</span>.ACTION_UP:
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
      performClick()
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>
}

<span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">boolean</span> <span style="font-weight: bold;">performClick</span>() {
  <span style="font-weight: bold;">if</span> (mOnClickListener != <span style="font-weight: bold; text-decoration: underline;">null</span>) {
    mOnClickListener.onClick(<span style="font-weight: bold;">this</span>)
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfd0beac" class="outline-2">
<h2 id="orgfd0beac"><span class="section-number-2">9.</span> <code>ViewGroup</code> 事件分发机制</h2>
<div class="outline-text-2" id="text-9">
<ol class="org-ol">
<li>事件首先传递到 <code>ViewGroup</code> 的 <code>dispatchTouchEvent</code></li>
<li><code>ViewGroup</code> 的 <code>dispatchTouchEvent</code> 中根据 <code>onInterceptTouchEvent</code> 判断事件是否需要被拦截，默认不拦截</li>
<li>如果被拦截，事件将不会传递给子 <code>View</code></li>
<li>如果不拦截，事件传递给子 <code>View</code>, 之后与 <code>View</code> 事件传递一样</li>
</ol>
</div>
</div>
<div id="outline-container-org96b55fd" class="outline-2">
<h2 id="org96b55fd"><span class="section-number-2">10.</span> 如何启动 <code>Service</code>?</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li><code>startService</code>: 在主动停止前，一直存在，与调用组件生命周期无关</li>
<li><code>bindService</code>: 调用者组件退出后，=Service= 也会退出</li>
</ul>
</div>
</div>
<div id="outline-container-org96a3e08" class="outline-2">
<h2 id="org96a3e08"><span class="section-number-2">11.</span> <code>Service</code> 生命周期？</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li><code>startService</code>: <code>onCreate</code> -&gt; <code>onStartCommand</code> -&gt; <code>onDestroy</code></li>
<li><code>bindService</code>: <code>onCreate</code> -&gt; <code>onBind</code> -&gt; <code>onUnbind</code> -&gt; <code>onDestroy</code></li>
<li>both: <code>onCreate</code> -&gt; <code>onStartCommand</code> -&gt; <code>onBind</code> -&gt; <code>onUnbind</code> -&gt; <code>onDestroy</code></li>
</ul>
</div>
</div>
<div id="outline-container-org1db1630" class="outline-2">
<h2 id="org1db1630"><span class="section-number-2">12.</span> <code>Service</code> 如何与其它组件通信？</h2>
<div class="outline-text-2" id="text-12">
<p>
通过 <code>ServiceConnection.onBind</code> 提供的 <code>IBinder</code> 实例参数通信。=IBinder= 实例可返回 <code>Service</code> 实例，然后调用其公共方法进行通信；也可在通过 <code>Messenger</code> 实现跨进程通信，在 <code>Service</code> 中创建一个 <code>Handler</code>, 再创建一个引用此 <code>Handler</code> 的 <code>Messenger</code>, 在 <code>Service</code> 的 <code>onBind</code> 中返回 <code>Messenger</code> 的 <code>binder</code>, 客户端的 <code>ServiceConnection.onBind</code> 中根据此 <code>binder</code> 创建一个 <code>Messenger</code> 实例，客户端即可用此 <code>Messenger</code> 实例发送消息给 <code>Service</code>.
</p>

<p>
需要双向通信时，可在 <code>Service</code> 中保存客户 <code>Messenger</code>, 客户通过设置发送 <code>Message</code> 的 <code>replyTo</code> 传递客户 <code>Messenger</code> 给 <code>Service</code>.
</p>
</div>
</div>
<div id="outline-container-orgbf64be2" class="outline-2">
<h2 id="orgbf64be2"><span class="section-number-2">13.</span> Why use compose?</h2>
<div class="outline-text-2" id="text-13">
<ol class="org-ol">
<li>更少的代码，不用在 xml 和 kotlin 间切换</li>
<li>声明式 api, 更加直观，类似于从 jQuery 到 react/vue 的变化</li>
<li>实时预览，开发效率更高</li>
<li>功能强大，自定义动画、手势都比较容易实现</li>
</ol>
</div>
</div>
<div id="outline-container-orgf4b5a66" class="outline-2">
<h2 id="orgf4b5a66"><span class="section-number-2">14.</span> 协程的底层原理是什么？</h2>
<div class="outline-text-2" id="text-14">
<p>
对 <code>suspend</code> 方法进行封装，在编译时生成对应的 <code>Continuation</code> 类，在其中保存代码块的运行状态，在合适的时机返回或取消。协程会给子协程添加一个标记，根据标记及运行状态管理子协程的调用。
</p>
</div>
</div>
<div id="outline-container-org91e4121" class="outline-2">
<h2 id="org91e4121"><span class="section-number-2">15.</span> 为什么要用协程？</h2>
<div class="outline-text-2" id="text-15">
<p>
可以用同步的方式写异步的代码，不用管理一个个的回调。
</p>
</div>
</div>
<div id="outline-container-org47e1414" class="outline-2">
<h2 id="org47e1414"><span class="section-number-2">16.</span> Glide 缓存机制</h2>
<div class="outline-text-2" id="text-16">
<p>
分为内存缓存和磁盘缓存。
</p>

<p>
内存缓存有两级，当前正在使用的用弱引用缓存，未使用的用 lru 算法缓存。
</p>

<p>
磁盘缓存也使用 lru 算法缓存。
</p>
</div>
</div>
<div id="outline-container-org2e97f4c" class="outline-2">
<h2 id="org2e97f4c"><span class="section-number-2">17.</span> 什么是 ANR?</h2>
<div class="outline-text-2" id="text-17">
<p>
应用程序如果超过一定时间未响应，系统会弹出一个应用无响应对话框，提示用户是否继续等待。主线程(Activity, Service)为5秒，BroadCastReceiver 是10秒。
</p>
</div>
</div>
<div id="outline-container-orgd582df3" class="outline-2">
<h2 id="orgd582df3"><span class="section-number-2">18.</span> 如何避免 ANR？</h2>
<div class="outline-text-2" id="text-18">
<p>
将所有耗时操作放在非 UI 线程运行，如文件读写、数据库操作、网络请求以及复杂逻辑运算等。如需用户等待，可显示进度条。
</p>
</div>
</div>
<div id="outline-container-org76fae0a" class="outline-2">
<h2 id="org76fae0a"><span class="section-number-2">19.</span> 创建型设计模式有哪些？</h2>
<div class="outline-text-2" id="text-19">
<p>
5种：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式
</p>
</div>
</div>
<div id="outline-container-org2bf63dd" class="outline-2">
<h2 id="org2bf63dd"><span class="section-number-2">20.</span> 结构型设计模式有哪些？</h2>
<div class="outline-text-2" id="text-20">
<p>
7种：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式
</p>
</div>
</div>
<div id="outline-container-org25dd0ea" class="outline-2">
<h2 id="org25dd0ea"><span class="section-number-2">21.</span> 行为型设计模式有哪些？</h2>
<div class="outline-text-2" id="text-21">
<p>
11种：策略模式，观察者模式，迭代器模式，命令模式，状态模式，模板方法模式，责任链模式，备忘录模式，访问者模式，中介者模式，解释器模式
</p>
</div>
</div>
<div id="outline-container-org01dc189" class="outline-2">
<h2 id="org01dc189"><span class="section-number-2">22.</span> 为何要实现 <code>equals</code> 方法？</h2>
<div class="outline-text-2" id="text-22">
<p>
默认的 <code>equals</code> 方法继承自 <code>Any</code>, 检查是否为同一个对象，跟引用检查一样。意味着所有对象默认都是唯一的。
</p>
</div>
</div>
<div id="outline-container-org2b8f0d8" class="outline-2">
<h2 id="org2b8f0d8"><span class="section-number-2">23.</span> <code>hashCode</code> 有什么需要注意的？</h2>
<div class="outline-text-2" id="text-23">
<p>
只在将其对象添加到容器中时才会计算。
</p>
</div>
</div>
<div id="outline-container-orge09a144" class="outline-2">
<h2 id="orge09a144"><span class="section-number-2">24.</span> 事件传递过程？</h2>
<div class="outline-text-2" id="text-24">
<p>
一个 <code>MotionEvent</code> 产生后，按 <code>Activity</code> -&gt; <code>Window</code> -&gt; <code>decorView</code> -&gt; <code>View</code> 顺序传递。
</p>
</div>
</div>
<div id="outline-container-orga4e0a0d" class="outline-2">
<h2 id="orga4e0a0d"><span class="section-number-2">25.</span> Window, WindowManager, WMS, SurfaceFlinger</h2>
<div class="outline-text-2" id="text-25">
<ul class="org-ul">
<li><code>Window</code>: 抽象概念，没有实际对应，以 <code>View</code> 的形式存在，通过 <code>PhoneWindow</code> 实现</li>
<li><code>WindowManager</code>: 外界访问 <code>Window</code> 的入口，内部与 <code>WMS</code> 的交互是个 IPC 过程</li>
<li><code>WMS</code>: 窗口管理，作为系统级服务单独运行在一个进程</li>
<li><code>SurfaceFlinger</code>: 将 <code>WMS</code> 维护的窗口按一定次序混合后显示到屏幕上</li>
</ul>
</div>
</div>
<div id="outline-container-org782901a" class="outline-2">
<h2 id="org782901a"><span class="section-number-2">26.</span> <code>Handler</code>, <code>MessageQueue</code>, <code>Looper</code></h2>
<div class="outline-text-2" id="text-26">
<ul class="org-ul">
<li><code>Hanlder</code>: 开发时直接接触的类，内部持有 <code>MessageQueue</code> 和 <code>Looper</code></li>
<li><code>MessageQueue</code>: 消息队列，内部通过单链表存储消息</li>
<li><code>Looper</code>: 内部持有 <code>MessageQueue</code>, 循环查看是否有新消息，有就处理，没有就阻塞</li>
<li>为何主线程不会因为 <code>Looper</code> 阻塞：60 帧的手机上系统每 16ms 会发送一个 UI 刷新消息唤醒</li>
</ul>
</div>
</div>
<div id="outline-container-org22b567a" class="outline-2">
<h2 id="org22b567a"><span class="section-number-2">27.</span> IPC 方式</h2>
<div class="outline-text-2" id="text-27">
<ul class="org-ul">
<li><code>Intent</code> <code>Extras/Bundle</code>: 要求传递的数据可被序列化，实现 <code>Serializable/Parcelabe</code>, 适用于四大组件间通信</li>
<li>文件共享：实时性不高的场景</li>
<li>Socket: 适用于网络数据交换</li>
<li><code>ContentProvider</code>: 基于 <code>Binder</code> 实现，适用于一对多进程间数据共享</li>
<li><code>Messenger</code>: 基于 <code>AIDL</code> 实现，服务端串行处理，主要用于传递消息，适用于低并发一对多通信</li>
<li><code>AIDL</code></li>
</ul>
</div>
</div>
<div id="outline-container-org8ebd4af" class="outline-2">
<h2 id="org8ebd4af"><span class="section-number-2">28.</span> <code>Binder</code></h2>
<div class="outline-text-2" id="text-28">
<p>
安卓进程间通信的基础，基于客户端-服务端通信方式。
</p>

<p>
优势在于使用 mmap 一次数据拷贝实现 IPC，传统 IPC: 用户 A 空间 -&gt; 内核 -&gt; 用户 B 空间；mmap 将内核与用户 B 空间映射，实现直接从用户 A 空间拷贝到用户 B 空间。
</p>
</div>
</div>
<div id="outline-container-orga4958a1" class="outline-2">
<h2 id="orga4958a1"><span class="section-number-2">29.</span> App 启动流程</h2>
<div class="outline-text-2" id="text-29">
<p>
启动器中点击一个应用图标 -&gt; 通过 AMS 查找应用进程，若不存在就通过 Zygote 进程 fork
</p>
</div>
</div>
<div id="outline-container-orgdfb8a73" class="outline-2">
<h2 id="orgdfb8a73"><span class="section-number-2">30.</span> 进程保活</h2>
<div class="outline-text-2" id="text-30">
<ul class="org-ul">
<li>进程优先级：前台进程，可见进程，服务进程，后台进程</li>
<li>被 kill 场景：切到后台内存不足时被杀；切到后台厂商省电机制杀死；用户主动清理</li>
<li>保活方式：挂一个1像素 <code>Activity</code> 将进程优先级提高到前台进程；启动一个前台服务；广播拉活；定时任务拉活</li>
</ul>
</div>
</div>
<div id="outline-container-org4f99b4d" class="outline-2">
<h2 id="org4f99b4d"><span class="section-number-2">31.</span> UI 卡顿优化</h2>
<div class="outline-text-2" id="text-31">
<ul class="org-ul">
<li>减少布局层级</li>
<li>避免在 <code>Draw</code> 中频繁创建对象、执行耗时操作</li>
</ul>
</div>
</div>
<div id="outline-container-orgf7be4ac" class="outline-2">
<h2 id="orgf7be4ac"><span class="section-number-2">32.</span> 内存泄漏场景及规避</h2>
<div class="outline-text-2" id="text-32">
<ol class="org-ol">
<li>静态变量、单例强引用跟生命周期相关的数据或资源</li>
<li>IO 流忘记主动释放(使用 <code>use</code> 方法)</li>
<li>内部类持有外部引用</li>
<li><code>Handler</code> 在界面销毁时未清空消息队列</li>
</ol>
</div>
</div>
<div id="outline-container-org0ae9cea" class="outline-2">
<h2 id="org0ae9cea"><span class="section-number-2">33.</span> OOM 场景及规避</h2>
<div class="outline-text-2" id="text-33">
<ul class="org-ul">
<li>加载大图：减小图片</li>
<li>内存泄漏</li>
</ul>
</div>
</div>
<div id="outline-container-org96d01ea" class="outline-2">
<h2 id="org96d01ea"><span class="section-number-2">34.</span> <code>AIDL</code></h2>
</div>
<div id="outline-container-orgd2b34c9" class="outline-2">
<h2 id="orgd2b34c9"><span class="section-number-2">35.</span> 动画</h2>
</div>
<div id="outline-container-org095f187" class="outline-2">
<h2 id="org095f187"><span class="section-number-2">36.</span> <code>String</code>, <code>StringBuilder</code>, <code>StringBuffer</code> 对比</h2>
<div class="outline-text-2" id="text-36">
<p>
<code>String</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> are all classes in Java that are used to represent a sequence of characters. However, they have some key differences that you should be aware of:
</p>

<ol class="org-ol">
<li><code>String</code> is an immutable class, which means that once you create a <code>String</code> object, you cannot modify it. If you want to modify a <code>String</code>, you must create a new <code>String</code> object.</li>
<li><code>StringBuilder</code> is a mutable class that allows you to modify a string by appending, inserting, or deleting characters. It is generally more efficient than <code>StringBuffer</code> for single-threaded scenarios, as it does not synchronize operations.</li>
<li><code>StringBuffer</code> is also a mutable class, but it synchronizes all operations to ensure thread safety. This makes it slower than <code>StringBuilder</code>, but it is more suitable for use in multithreaded environments where multiple threads may access the same string concurrently.</li>
</ol>

<p>
Overall, you should use <code>String</code> when you need an immutable string, <code>StringBuilder</code> when you need a mutable string and you are not concerned about thread safety, and <code>StringBuffer</code> when you need a mutable string and you need to ensure thread safety.
</p>
</div>
</div>
<div id="outline-container-org54701cb" class="outline-2">
<h2 id="org54701cb"><span class="section-number-2">37.</span> <code>ContentProvider</code></h2>
</div>
<div id="outline-container-orgd2ae665" class="outline-2">
<h2 id="orgd2ae665"><span class="section-number-2">38.</span> <code>Broadcast</code></h2>
</div>
<div id="outline-container-orgca5f573" class="outline-2">
<h2 id="orgca5f573"><span class="section-number-2">39.</span> 如何排查内存泄漏？</h2>
<div class="outline-text-2" id="text-39">
<p>
LeakCanary
</p>
</div>
</div>
<div id="outline-container-org4fd729d" class="outline-2">
<h2 id="org4fd729d"><span class="section-number-2">40.</span> 性能监控</h2>
<div class="outline-text-2" id="text-40">
<p>
<a href="https://ui.perfetto.dev/">Perfetto</a>
</p>
</div>
</div>
<div id="outline-container-org2aa4c60" class="outline-2">
<h2 id="org2aa4c60"><span class="section-number-2">41.</span> App 启动优化</h2>
</div>
<div id="outline-container-orgfef352c" class="outline-2">
<h2 id="orgfef352c"><span class="section-number-2">42.</span> 屏幕旋转时会发生什么？</h2>
</div>
<div id="outline-container-org7211c39" class="outline-2">
<h2 id="org7211c39"><span class="section-number-2">43.</span> 三种 <code>Context</code></h2>
</div>
<div id="outline-container-org2ca9877" class="outline-2">
<h2 id="org2ca9877"><span class="section-number-2">44.</span> <code>HashMap</code> 中 hash 冲突解决及扩容机制</h2>
</div>
<div id="outline-container-org9c4ad05" class="outline-2">
<h2 id="org9c4ad05"><span class="section-number-2">45.</span> 类加载机制</h2>
<div class="outline-text-2" id="text-45">
</div>
<div id="outline-container-org2a52e29" class="outline-3">
<h3 id="org2a52e29"><span class="section-number-3">45.1.</span> 类加载<a href="https://juejin.cn/post/6844903930242007053#heading-6">生命周期</a></h3>
<div class="outline-text-3" id="text-45-1">
<ol class="org-ol">
<li>load: 将 class 字节码文件载入内存</li>
<li>check: 检测版本是否兼容等</li>
<li>prepare: 为静态变量分配堆内存</li>
<li>parse: 将符号引用转为直接引用，为类的静态变量寻址</li>
<li>cinit: 执行静态代码块</li>
</ol>
</div>
</div>
<div id="outline-container-org3a9ea32" class="outline-3">
<h3 id="org3a9ea32"><span class="section-number-3">45.2.</span> <a href="https://juejin.cn/post/6844903940094427150">加载</a></h3>
<div class="outline-text-3" id="text-45-2">
</div>
<div id="outline-container-org16b2e18" class="outline-4">
<h4 id="org16b2e18"><span class="section-number-4">45.2.1.</span> 类加载双亲委托机制</h4>
<div class="outline-text-4" id="text-45-2-1">
<p>
先从父的类加载器中查找加载，一级一级找上去，没找到时再自己加载
</p>

<p>
双亲委托优势：
</p>
<ol class="org-ol">
<li>复用：已经加载过的类不用重复加载</li>
<li>隔离：防止底层类被外部篡改</li>
</ol>
</div>
</div>
<div id="outline-container-org07b9887" class="outline-4">
<h4 id="org07b9887"><span class="section-number-4">45.2.2.</span> jvm 类加载器</h4>
<div class="outline-text-4" id="text-45-2-2">
<ol class="org-ol">
<li>BootstrapClassLoader</li>
<li>ExtClassLoader</li>
<li>AppClassLoader</li>
</ol>
</div>
</div>
<div id="outline-container-org43f7a9c" class="outline-4">
<h4 id="org43f7a9c"><span class="section-number-4">45.2.3.</span> Android 类加载器</h4>
<div class="outline-text-4" id="text-45-2-3">
<ol class="org-ol">
<li>BootClassLoader</li>
<li>PathClassLoader</li>
<li>DexClassLoader</li>
</ol>
</div>
</div>
<div id="outline-container-orga3ecfe7" class="outline-4">
<h4 id="orga3ecfe7"><span class="section-number-4">45.2.4.</span> jvm 与 android 类加载器区别</h4>
<div class="outline-text-4" id="text-45-2-4">
<ol class="org-ol">
<li>class 与 dex 文件</li>
<li>JIT(Just In Time) 与 AOT(Ahead Of Time)</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org7e5109f" class="outline-2">
<h2 id="org7e5109f"><span class="section-number-2">46.</span> 开源库源码及实现原理</h2>
</div>
<div id="outline-container-org0a3c44a" class="outline-2">
<h2 id="org0a3c44a"><span class="section-number-2">47.</span> LruCache 原理及实现</h2>
</div>
<div id="outline-container-org237a4eb" class="outline-2">
<h2 id="org237a4eb"><span class="section-number-2">48.</span> 自定义 <code>View</code></h2>
</div>
<div id="outline-container-orge560487" class="outline-2">
<h2 id="orge560487"><span class="section-number-2">49.</span> 怎么检测卡顿</h2>
</div>
<div id="outline-container-org5771025" class="outline-2">
<h2 id="org5771025"><span class="section-number-2">50.</span> <code>Handler</code> 中 <code>post/postDelay</code> 如何实现？</h2>
<div class="outline-text-2" id="text-50">
<ol class="org-ol">
<li><code>MessageQueue enqueue</code> 时设置 <code>when</code> 为与系统启动时间的相对值</li>
<li>如果是延迟消息，将其根据 <code>when</code> 插入到消息队列中</li>
<li>如果是非延迟消息，将其插入头部</li>
<li><code>looper</code> 从 <code>MessageQueue.next()</code> 获取下一个消息时，根据 <code>when</code> 判断是返回可处理消息或更新下次唤醒的延时</li>
<li>然后交给 <code>handler</code> 的回调去处理</li>
</ol>

<p>
Android 的 Handler 类是一个消息传递机制，它可以在不同的线程之间传递消息和执行任务。Handler 的 postDelayed 方法可以实现延迟执行任务的功能。
</p>

<p>
在实现原理上，Handler 的 postDelayed 方法首先将执行的任务封装成一个消息对象，并设置延迟的时间。然后，Handler 会将消息放入一个消息队列中，等待执行。在等待期间，Handler 会每隔一段时间检查消息队列中是否有过期的消息，如果有，则将其取出，并执行对应的任务。
</p>

<p>
简而言之，Handler 的 postDelayed 方法是通过消息队列和定时器，来实现延迟任务的执行的。
</p>
</div>
</div>
<div id="outline-container-org29128be" class="outline-2">
<h2 id="org29128be"><span class="section-number-2">51.</span> Kotlin 中 extension 是如何实现的？</h2>
<div class="outline-text-2" id="text-51">
<p>
将其转换成静态方法实现的。
</p>
<div class="org-src-container">
<pre class="src src-kotlin">fun String.greet(hello: String = "Hello") = "$hello, $this"
</pre>
</div>

<p>
在 Android Studio 中执行 <code>Kotlin Bytecode</code> 命令后，会显示对应的字节码文件(.class), 反编译(Decompile) 即可看到对应的 Java 文件。
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="font-weight: bold; text-decoration: underline;">@NotNull</span>
<span style="font-weight: bold;">public</span> <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">final</span> <span style="font-weight: bold; text-decoration: underline;">String</span> <span style="font-weight: bold;">greet</span>(<span style="font-weight: bold; text-decoration: underline;">@NotNull</span> String $this$greet, <span style="font-weight: bold; text-decoration: underline;">@NotNull</span> <span style="font-weight: bold; text-decoration: underline;">String</span> <span style="font-weight: bold; font-style: italic;">hello</span>) {
  Intrinsics.checkNotNullParameter($this$greet, <span style="font-style: italic;">"$this$greet"</span>);
  Intrinsics.checkNotNullParameter(hello, <span style="font-style: italic;">"hello"</span>);
  <span style="font-weight: bold;">return</span> hello + <span style="font-style: italic;">", "</span> + $this$greet;
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">$FF: synthetic method</span>
<span style="font-weight: bold;">public</span> <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">String</span> <span style="font-weight: bold;">greet$default</span>(<span style="font-weight: bold; text-decoration: underline;">String</span> <span style="font-weight: bold; font-style: italic;">var0</span>, <span style="font-weight: bold; text-decoration: underline;">String</span> <span style="font-weight: bold; font-style: italic;">var1</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">var2</span>, <span style="font-weight: bold; text-decoration: underline;">Object</span> <span style="font-weight: bold; font-style: italic;">var3</span>) {
  <span style="font-weight: bold;">if</span> ((var2 &amp; 1) != 0) {
    var1 = <span style="font-style: italic;">"Hello"</span>;
  }

  <span style="font-weight: bold;">return</span> greet(var0, var1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb6dc954" class="outline-2">
<h2 id="orgb6dc954"><span class="section-number-2">52.</span> 掉帧检测</h2>
<div class="outline-text-2" id="text-52">
<div class="org-src-container">
<pre class="src src-sh">adb shell dumpsys gfxinfo [package.name]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kotlin">val frameCallback: Choreographer.FrameCallback =
    object : Choreographer.FrameCallback {
      var last = 0L
      override fun doFrame(frameTimeNanos: Long) {
        if (last != 0L) {
          val time = (frameTimeNanos - last) / 1000_000
          if (time &gt; 16) {
            val frames = time / 16
            Logger.t("FrameLost").error("time: $time, lost frames: $frames")
          }
        }
        last = frameTimeNanos
        Choreographer.getInstance().postFrameCallback(this)
      }
    }

Choreographer.getInstance().postFrameCallback(frameCallback)
</pre>
</div>
</div>
</div>
<div id="outline-container-org538b592" class="outline-2">
<h2 id="org538b592"><span class="section-number-2">53.</span> <code>final</code> 关键字的作用是什么？</h2>
<div class="outline-text-2" id="text-53">
<ol class="org-ol">
<li>当一个类被 <code>final</code> 修饰时，其不能被继承。</li>
<li>当一个方法或属性被 <code>final</code> 修饰时，它不能被子类重写。</li>
<li>当一个变量被 <code>final</code> 修饰时，其值不能被修改。</li>
<li>kotlin 中类和成员默认为 <code>final</code> 修饰。</li>
<li>kotlin 中函数参数默认为 <code>val</code>.</li>
</ol>

<p>
<code>val</code> 表示只读，=getter= 方法返回的值是可变的：
</p>
<div class="org-src-container">
<pre class="src src-kotlin">var age = 13
val isAdult: Boolean
  get() = age &gt;= 18
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class="links"><a href="#content">T</a><a href="index.html">H</a><a id="share-img">I</a><a href="20210629191000-000_index.html">0</a></div><script src="static/dom2img.min.js" type="text/javascript"></script><script src="static/x.js" type="text/javascript"></script>
</div>
</body>
</html>