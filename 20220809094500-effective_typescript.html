<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-09-07 Wed 22:56 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Effective TypeScript</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="static/x.css" type="text/css"/><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Effective TypeScript</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org46ea25b">1. Effective Typescript</a>
<ul>
<li><a href="#orge609a0e">1.1. Preface</a></li>
<li><a href="#orgb082a5c">1.2. Getting to Know TypeScript</a>
<ul>
<li><a href="#org326cb48">1.2.1. Item 1: Understand the Relationship Between TypeScript and JavaScript</a></li>
<li><a href="#orge487155">1.2.2. Item 2: Know Which TypeScript Options You're Using</a></li>
<li><a href="#orgf1b0148">1.2.3. Item 3: Understand That Code Generation Is Independent of Types</a>
<ul>
<li><a href="#orgf2148cf">1.2.3.1. Code with Type Errors Can Produce Output</a></li>
<li><a href="#org0067ca7">1.2.3.2. You Cannot Check TypeScript Types at Runtime</a></li>
<li><a href="#org6dce52a">1.2.3.3. You Cannot Overload a Function Based on TypeScript Types</a></li>
<li><a href="#orgf3f0967">1.2.3.4. Things to Remember</a></li>
</ul>
</li>
<li><a href="#orgd91c54c">1.2.4. Item 4: Get Comfortable with Structural Typing</a></li>
<li><a href="#org5641bd9">1.2.5. Item 5: Limit Use of the any Type</a></li>
</ul>
</li>
<li><a href="#org92c20df">1.3. TypeScript's Type System</a>
<ul>
<li><a href="#org85947f3">1.3.1. Item 6: Use Your Editor to Interrogate and Explore the Type System</a></li>
<li><a href="#orga05a00a">1.3.2. Item 7: Think of Types as Sets of Values</a></li>
<li><a href="#orgbc0a96f">1.3.3. Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space</a></li>
<li><a href="#orgf32eff4">1.3.4. Item 9: Prefer Type Declarations to Type Assertions</a></li>
<li><a href="#org89eabfc">1.3.5. Item 10: Avoid Object Wrapper Types(String, Number, Boolean, Symbol, BigInt)</a></li>
<li><a href="#org8c0acd9">1.3.6. Item 11: Recognize the Limits of Excess Property Checking</a></li>
<li><a href="#org9705ccf">1.3.7. Item 12: Apply Types to Entire Function Expressions When Possible</a></li>
<li><a href="#org946563b">1.3.8. Item 13: Know the Differences Between type and interface</a></li>
<li><a href="#org5c49104">1.3.9. Item 14: Use Type Operations and Generics to Avoid Repeating Yourself</a></li>
<li><a href="#orgbd067bb">1.3.10. Item 15: Use Index Signatures for Dynamic Data</a></li>
<li><a href="#org1c34f7e">1.3.11. Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures</a></li>
<li><a href="#org12ddb99">1.3.12. Item 17: Use readonly to Avoid Errors Associated with Mutation</a></li>
<li><a href="#orgd6a1d9e">1.3.13. Item 18: Use Mapped Types to Keep Values in Sync</a></li>
</ul>
</li>
<li><a href="#org2ee1a39">1.4. Type Inference</a>
<ul>
<li><a href="#orgc82ac00">1.4.1. Item 19: Avoid Cluttering Your Code with Inferable Types</a></li>
<li><a href="#orgd9c7c33">1.4.2. Item 20: Use Different Variables for Different Types</a></li>
<li><a href="#orge87d487">1.4.3. Item 21: Understand Type Widening</a></li>
<li><a href="#orgef1409f">1.4.4. Item 22: Understand Type Narrowing</a></li>
<li><a href="#org8b9aba0">1.4.5. Item 23: Create Objects All at Once</a></li>
<li><a href="#org68255b2">1.4.6. Item 24: Be Consistent in Your Use of Aliases</a></li>
<li><a href="#org0b7d53a">1.4.7. Item 25: Use async Functions Instead of Callbacks for Asynchronous Code</a></li>
<li><a href="#org156ca7b">1.4.8. Item 26: Understand How Context Is Used in Type Inference</a></li>
<li><a href="#org33450b7">1.4.9. Item 27: Use Functional Constructs and Libraries to Help Types Flow</a></li>
</ul>
</li>
<li><a href="#orgb732c9e">1.5. Type Design</a>
<ul>
<li><a href="#orgc183f65">1.5.1. Item 28: Prefer Types That Always Represent Valid States</a></li>
<li><a href="#org37e0890">1.5.2. Item 29: Be Liberal in What You Accept and Strict in What You Produce</a></li>
<li><a href="#orgb8993ff">1.5.3. Item 30: Don't Repeat Type Information in Documentation</a></li>
<li><a href="#orga2c8179">1.5.4. Item 31: Push Null Values to the Perimeter of Your Types</a></li>
<li><a href="#orgef27304">1.5.5. Item 32: Prefer Unions of Interfaces to Interfaces of Unions</a></li>
<li><a href="#org4b4ce61">1.5.6. Item 33: Prefer More Precise Alternatives to String Types</a></li>
<li><a href="#org3617d29">1.5.7. Item 34: Prefer Incomplete Types to Inaccurate Types</a></li>
<li><a href="#org6d6e6a6">1.5.8. Item 35: Generate Types from APIs and Specs, Not Data</a></li>
<li><a href="#orgce79041">1.5.9. Item 36: Name Types Using the Language of Your Problem Domain</a></li>
<li><a href="#orgaca5ce1">1.5.10. Item 37: Consider "Brands" for Nominal Typing</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<dl class="org-dl">
<dt>author</dt><dd>Dan Vanderkam</dd>
</dl>

<div id="outline-container-org46ea25b" class="outline-2">
<h2 id="org46ea25b"><span class="section-number-2">1.</span> Effective Typescript</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orge609a0e" class="outline-3">
<h3 id="orge609a0e"><span class="section-number-3">1.1.</span> Preface</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Whereas a reference book will explain the five ways that a language lets you do X, an Effective book will tell you which of those five to use and why.
</p>
</div>
</div>
<div id="outline-container-orgb082a5c" class="outline-3">
<h3 id="orgb082a5c"><span class="section-number-3">1.2.</span> Getting to Know TypeScript</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org326cb48" class="outline-4">
<h4 id="org326cb48"><span class="section-number-4">1.2.1.</span> Item 1: Understand the Relationship Between TypeScript and JavaScript</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
TypeScript is a superset of JavaScript.
</p>
</div>
</div>
<div id="outline-container-orge487155" class="outline-4">
<h4 id="orge487155"><span class="section-number-4">1.2.2.</span> Item 2: Know Which TypeScript Options You're Using</h4>
</div>
<div id="outline-container-orgf1b0148" class="outline-4">
<h4 id="orgf1b0148"><span class="section-number-4">1.2.3.</span> Item 3: Understand That Code Generation Is Independent of Types</h4>
<div class="outline-text-4" id="text-1-2-3">
</div>
<div id="outline-container-orgf2148cf" class="outline-5">
<h5 id="orgf2148cf"><span class="section-number-5">1.2.3.1.</span> Code with Type Errors Can Produce Output</h5>
</div>
<div id="outline-container-org0067ca7" class="outline-5">
<h5 id="org0067ca7"><span class="section-number-5">1.2.3.2.</span> You Cannot Check TypeScript Types at Runtime</h5>
<div class="outline-text-5" id="text-1-2-3-2">
<div class="org-src-container">
<pre class="src src-typescript">interface Square {
  width: number
}
interface Rectangle extends Square {
  height: number
}
type Shape = Square | Rectangle
function calculateArea(shape: Shape) {
  if ('height' in shape) {
    shape; // Type is Rectangle
    return shape.width * shape.height
  } else {
    shape; // Type is Square
    return shape.width * shape.width
  }
}
</pre>
</div>
<p>
Another way would have been to introduct a "tag" to explicitly store the type in a way that's available at runtime:
</p>
<div class="org-src-container">
<pre class="src src-typescript">interface Square {
  kind: 'square'
  width: number
}
interface Rectangle {
  kind: 'rectangle'
  height: number
  width: number
}
type Shape = Square | Rectangle
function calculateArea(shape: Shpae) {
  if (shape.kind === 'rectangle') {
    shape // Type is Rectangle
    return shape.width * shape.height
  } else {
    shape // Type is Square
    return shape.width * shape.width
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org6dce52a" class="outline-5">
<h5 id="org6dce52a"><span class="section-number-5">1.2.3.3.</span> You Cannot Overload a Function Based on TypeScript Types</h5>
<div class="outline-text-5" id="text-1-2-3-3">
<p>
You can provide multiple declarations for a function, but only a single implementation:
</p>
<div class="org-src-container">
<pre class="src src-typescript">function add(a: number, b: number): number
function add(a: string, b: string): string
function add(a, b) {
  return a + b
}
const three = add(1, 2) // Type is number
const twelve = add('1', '2') // Type is string
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf3f0967" class="outline-5">
<h5 id="orgf3f0967"><span class="section-number-5">1.2.3.4.</span> Things to Remember</h5>
<div class="outline-text-5" id="text-1-2-3-4">
<ul class="org-ul">
<li>Code generation is independent of the type system. This means that TypeScript types cannot affect the runtime behavior or performance of your code.</li>
<li>It is possible for a program with type errors to produce code.</li>
<li>TypeScript types are not available at runtime. To query a type at runtime, you need some way to reconstruct it. Tagged unions and property checking are common ways to do this. Some constructs, such as class, introduce both a TypeScript type and a value that is available at runtime.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd91c54c" class="outline-4">
<h4 id="orgd91c54c"><span class="section-number-4">1.2.4.</span> Item 4: Get Comfortable with Structural Typing</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>Understand that JavaScript is duck typed and TypeScript uses structural typing to model this: values assignable to your interfaces might have properties beyond those explicitly listed in your type definitions. Types are not "sealed".</li>
<li>Be aware that classes also follow structural typing rules. You may not have an instance of the class you expect!</li>
<li>Use structural typing to facilitate unit testing.</li>
</ul>
</div>
</div>
<div id="outline-container-org5641bd9" class="outline-4">
<h4 id="org5641bd9"><span class="section-number-4">1.2.5.</span> Item 5: Limit Use of the any Type</h4>
</div>
</div>
<div id="outline-container-org92c20df" class="outline-3">
<h3 id="org92c20df"><span class="section-number-3">1.3.</span> TypeScript's Type System</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org85947f3" class="outline-4">
<h4 id="org85947f3"><span class="section-number-4">1.3.1.</span> Item 6: Use Your Editor to Interrogate and Explore the Type System</h4>
</div>
<div id="outline-container-orga05a00a" class="outline-4">
<h4 id="orga05a00a"><span class="section-number-4">1.3.2.</span> Item 7: Think of Types as Sets of Values</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>Think of types as sets of values (the type's domain). These sets can either be finite (e.g., boolean or literal types) or infinite (e.g., number or string).</li>
<li>TypeScript types form intersecting sets rather than a strict hierarchy. Two types can overlap without either being a subtype of the other.</li>
<li>Remember that an objet can still belong to a type even if it has additional properties that were not mentioned in the type declaration.</li>
<li>Type operations apply to a set's domain. The intersection of A and B is the intersection of A's domain and B's domain. For object types, this means that values in A &amp; B have the properties of both A and B.</li>
<li>Think of "extends", "assignable to", and "subtype of" as synonyms for "sybset of".</li>
</ul>
</div>
</div>
<div id="outline-container-orgbc0a96f" class="outline-4">
<h4 id="orgbc0a96f"><span class="section-number-4">1.3.3.</span> Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li>Every value has a type, but types do not have values. Constructs such as <code>type</code> and <code>interface</code> exist only in the type space.</li>
<li><code>typeof</code>, <code>this</code> and many other operators and keywords have different meanings in type space and value space.</li>
<li>Some constructs such as <code>class</code> or <code>enum</code> introduce both a type and a value.</li>
</ul>
</div>
</div>
<div id="outline-container-orgf32eff4" class="outline-4">
<h4 id="orgf32eff4"><span class="section-number-4">1.3.4.</span> Item 9: Prefer Type Declarations to Type Assertions</h4>
<div class="outline-text-4" id="text-1-3-4">
<ul class="org-ul">
<li>Prefer type declarations(: Type) to type assertions(as Type).</li>
<li>Use type assertions and non-null assertions when you know something about types that TypeScript does not.</li>
</ul>
</div>
</div>
<div id="outline-container-org89eabfc" class="outline-4">
<h4 id="org89eabfc"><span class="section-number-4">1.3.5.</span> Item 10: Avoid Object Wrapper Types(String, Number, Boolean, Symbol, BigInt)</h4>
</div>
<div id="outline-container-org8c0acd9" class="outline-4">
<h4 id="org8c0acd9"><span class="section-number-4">1.3.6.</span> Item 11: Recognize the Limits of Excess Property Checking</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
index signature
</p>
<div class="org-src-container">
<pre class="src src-typescript">interface Options {
  darkMode?: boolean
  [otherOptions: string]: unknown
}
</pre>
</div>

<p>
When you assign an object literal to a variable or pass it as an argument to a function, it undergoes excess property checking.
</p>
</div>
</div>
<div id="outline-container-org9705ccf" class="outline-4">
<h4 id="org9705ccf"><span class="section-number-4">1.3.7.</span> Item 12: Apply Types to Entire Function Expressions When Possible</h4>
<div class="outline-text-4" id="text-1-3-7">
<ul class="org-ul">
<li>Consider applying type annotations to entire function expressions, ranther than to their parameters and return type.</li>
<li>If you're writing the same type signature repeatedly, factor out a function type or look for an existing one. If you're a library author, provider types for common callbacks.</li>
<li>Use <code>typeof fn</code> to match the signature of another function.</li>
</ul>
</div>
</div>
<div id="outline-container-org946563b" class="outline-4">
<h4 id="org946563b"><span class="section-number-4">1.3.8.</span> Item 13: Know the Differences Between type and interface</h4>
<div class="outline-text-4" id="text-1-3-8">
<ul class="org-ul">
<li>Understand the differences and similarities between <code>type</code> and <code>interface</code>.</li>
<li>Know how to write the same types using either syntax.</li>
<li>In deciding which to use in your project, consider the established style and whether augmentation might be beneficial.</li>
</ul>
</div>
</div>
<div id="outline-container-org5c49104" class="outline-4">
<h4 id="org5c49104"><span class="section-number-4">1.3.9.</span> Item 14: Use Type Operations and Generics to Avoid Repeating Yourself</h4>
<div class="outline-text-4" id="text-1-3-9">
<div class="org-src-container">
<pre class="src src-typescript">type State = {
  userId: string
  pageTitle: string
  recentFiles: string[]
  pageContnets: string
}
type TopNavState = {
  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]
}
</pre>
</div>

<p>
<code>Pick</code>'s declaration in the standard library:
</p>
<div class="org-src-container">
<pre class="src src-typescript">type Pick&lt;T, K&gt; = { [k in K]: T[k] }
</pre>
</div>

<p>
Similar:
</p>
<div class="org-src-container">
<pre class="src src-typescript">type TopNavState = Pick&lt;State, 'userId' | 'pageTitle' | 'recentFiles'&gt;
</pre>
</div>

<ul class="org-ul">
<li>The DRY (don't repeat yourself) principle applies to types as much as it applies to logic.</li>
<li>Name types rather than repeating them. Use <code>extends</code> to avoid repeating fields in interfaces.</li>
<li>Build an understanding of the tools provided by TypeScript to map between types. These include <code>keyof</code>, <code>typeof</code>, indexing, and mapped types.</li>
<li>Generic types are the equivalent of functions for types. Use them to map between types instead of repeating types. Use <code>extends</code> to constrain generic types.</li>
<li>Familiarize yourself with generic types defined in the standard library such as <code>Pick</code>, <code>Partial</code>, and <code>ReturnType</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-orgbd067bb" class="outline-4">
<h4 id="orgbd067bb"><span class="section-number-4">1.3.10.</span> Item 15: Use Index Signatures for Dynamic Data</h4>
<div class="outline-text-4" id="text-1-3-10">
<div class="org-src-container">
<pre class="src src-typescript">type Vec3D = Record&lt;'x' | 'y' | 'z', number&gt;
// Type Vec3D = {
//  x: number
//  y: number
//  z: number
//}
type V3D = { [k in 'x' | 'y' | 'z']: number } // same as above

type ABC = { [k in 'a' | 'b' | 'c']: k extends 'b' ? string : number }
// Type ABC = {
//  a: number
//  b: string
//  c: number
//}
</pre>
</div>

<ul class="org-ul">
<li>Use index signatures when the properties of an object cannot be known until runtime&#x2013;for example, if you're loading them from a CSV file.</li>
<li>Consider adding <code>undefined</code> to the value type of an index signature for safer access.</li>
<li>Prefer more precise types to index signatures when possible: <code>interfaces</code>, <code>Records</code>, or mapped types.</li>
</ul>
</div>
</div>
<div id="outline-container-org1c34f7e" class="outline-4">
<h4 id="org1c34f7e"><span class="section-number-4">1.3.11.</span> Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures</h4>
</div>
<div id="outline-container-org12ddb99" class="outline-4">
<h4 id="org12ddb99"><span class="section-number-4">1.3.12.</span> Item 17: Use readonly to Avoid Errors Associated with Mutation</h4>
<div class="outline-text-4" id="text-1-3-12">
<ul class="org-ul">
<li>If yor function does not modify its parameters then declare them <code>readonly</code>. This makes its contract clearer and prevents inadvertent mutations in its implementation.</li>
<li>Use <code>readonly</code> to prevent errors with mutation and to find the palces in your code where mutations occur.</li>
<li>Understand the defference between <code>const</code> and <code>readonly</code>.</li>
<li>Understand that <code>readonly</code> is shallow.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd6a1d9e" class="outline-4">
<h4 id="orgd6a1d9e"><span class="section-number-4">1.3.13.</span> Item 18: Use Mapped Types to Keep Values in Sync</h4>
<div class="outline-text-4" id="text-1-3-13">
<div class="org-src-container">
<pre class="src src-typescript">const REQUIRES_UPDATE: { [k in keyof ScatterProps]: boolean } = {
  xs: true,
  ys: true,
  // ...
}

const PROPS_REQUIRING_UPDATE: (keyof ScatterProps)[] = [
  'xs',
  'ys',
  // ...
]
</pre>
</div>
<p>
Mapped types are ideal if you want one object to have exactly the same  properties as another.
</p>

<ul class="org-ul">
<li>Use mapped types to keep related values and types synchronized.</li>
<li>Consider using mapped types to force choices when adding new properties to an interface.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2ee1a39" class="outline-3">
<h3 id="org2ee1a39"><span class="section-number-3">1.4.</span> Type Inference</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orgc82ac00" class="outline-4">
<h4 id="orgc82ac00"><span class="section-number-4">1.4.1.</span> Item 19: Avoid Cluttering Your Code with Inferable Types</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>Avoid writing type annotations when TypeScript can infer the same type.</li>
<li>Ideally your code has type annotations in function/method signatures but not on local variables in their bodies.</li>
<li>Consider using explicit annotations for object literals and function return types even when they can be inferred. This will help prevent implementation errors from surfacing in user code.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd9c7c33" class="outline-4">
<h4 id="orgd9c7c33"><span class="section-number-4">1.4.2.</span> Item 20: Use Different Variables for Different Types</h4>
</div>
<div id="outline-container-orge87d487" class="outline-4">
<h4 id="orge87d487"><span class="section-number-4">1.4.3.</span> Item 21: Understand Type Widening</h4>
</div>
<div id="outline-container-orgef1409f" class="outline-4">
<h4 id="orgef1409f"><span class="section-number-4">1.4.4.</span> Item 22: Understand Type Narrowing</h4>
<div class="outline-text-4" id="text-1-4-4">
<div class="org-src-container">
<pre class="src src-typescript">function isInputElement(el: HTMLElement): el is HTMLInputElement {
  return 'value' in el
}

function isDefined&lt;T&gt;(x: T | undefined): x is T {
  return x !== undefined
}
</pre>
</div>

<p>
The <code>el is HTMLInputElement</code> as a return type tells the type checker that it can narrow the type of the parameter if the function returns <code>true</code>.
</p>

<ul class="org-ul">
<li>Understand how TypeScript narrows types based on conditionals and other types of control flow.</li>
<li>Use tagged/discriminated unions and user-defined type guards to help the process of narrowing.</li>
</ul>
</div>
</div>
<div id="outline-container-org8b9aba0" class="outline-4">
<h4 id="org8b9aba0"><span class="section-number-4">1.4.5.</span> Item 23: Create Objects All at Once</h4>
<div class="outline-text-4" id="text-1-4-5">
<div class="org-src-container">
<pre class="src src-typescript">declare let hasMiddle: boolean
const firstLast = { first: 'Harry', last: 'Truman' }
const president = { ...firstLast, ...(hasMiddle ? { middle: 'S' } : {}) }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-typescript">function addOptional&lt;T extends object, U extends object&gt;(
  a: T, b: U | null
): T &amp; Partial&lt;U&gt; {
  return { ...a, ...b }
}
declare let hasMiddle: boolean
const firstLast = { first: 'Harry', last: 'Truman' }
const president = addOptional(firstLast, hasMiddle ? { middle: 'S' } : null)
</pre>
</div>

<ul class="org-ul">
<li>Prefer to build objects all at once rather than piecemeal. Use object spread <code>({ ...a, ...b })</code> to add propertties in a type-safe way.</li>
<li>Know how to conditionally add properties to an object.</li>
</ul>
</div>
</div>
<div id="outline-container-org68255b2" class="outline-4">
<h4 id="org68255b2"><span class="section-number-4">1.4.6.</span> Item 24: Be Consistent in Your Use of Aliases</h4>
<div class="outline-text-4" id="text-1-4-6">
<ul class="org-ul">
<li>Aliasing can prevent TypeScript from narrowing types. If you create an alias for a variable, use it consistently.</li>
<li>Be aware of how function calls can invalidate type refinements on properties. Trust refinements on local variables more than on properties.</li>
</ul>
</div>
</div>
<div id="outline-container-org0b7d53a" class="outline-4">
<h4 id="org0b7d53a"><span class="section-number-4">1.4.7.</span> Item 25: Use async Functions Instead of Callbacks for Asynchronous Code</h4>
<div class="outline-text-4" id="text-1-4-7">
<div class="org-src-container">
<pre class="src src-typescript">async function fetchAll() {
  const [users, posts] = await Promise.all([fetchUsers(), fetchPosts()])
}

function timeout(ms: number): Promise&lt;never&gt; {
  return new Promise((_resolve, reject) =&gt; {
    setTimeout(() =&gt; reject('timeout'), ms)
  })
}

async function fetchWithTimeout(url: string, ms: number) {
  return Promise.race([fetch(url), timeout(ms)])
}
</pre>
</div>
<ul class="org-ul">
<li>Prefer <code>async</code> and <code>await</code> to row Promises when possible. They produce more concise, straightforward code and eliminate whole classes of errors.</li>
<li>If a function returns a Promise, declare it <code>async</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-org156ca7b" class="outline-4">
<h4 id="org156ca7b"><span class="section-number-4">1.4.8.</span> Item 26: Understand How Context Is Used in Type Inference</h4>
</div>
<div id="outline-container-org33450b7" class="outline-4">
<h4 id="org33450b7"><span class="section-number-4">1.4.9.</span> Item 27: Use Functional Constructs and Libraries to Help Types Flow</h4>
<div class="outline-text-4" id="text-1-4-9">
<ul class="org-ul">
<li>Use built-in functional constructs and those in utility libraries like <i>Lodash</i> instead of hand-rolled constructs to improve type flow, increase legibility, and reduce the need for explicit type annotations.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb732c9e" class="outline-3">
<h3 id="orgb732c9e"><span class="section-number-3">1.5.</span> Type Design</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orgc183f65" class="outline-4">
<h4 id="orgc183f65"><span class="section-number-4">1.5.1.</span> Item 28: Prefer Types That Always Represent Valid States</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li>Types that represent both valid and invalid states are likely to lead to confusing and error-prone code.</li>
<li>Prefer types that only represent valid states. Even if they are longer or harder to express, they will save you time and pain in the end.</li>
</ul>
</div>
</div>
<div id="outline-container-org37e0890" class="outline-4">
<h4 id="org37e0890"><span class="section-number-4">1.5.2.</span> Item 29: Be Liberal in What You Accept and Strict in What You Produce</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-typescript">type LngLat = { lng: number, lat: number }
type LngLatLike = LngLat | { lon: number, lat: number } | [number, number]

type Camera = {
  center: LngLat,
  zoom: number,
  bearing: number,
  pitch: number
}

type CameraOptions = Omit&lt;Partial&lt;Camera&gt;, 'center'&gt;  &amp; {
  center?: LngLatLike
}
type LngLatBounds =
  { northeast: LngLatLike, southwest: LngLatLike} |
  [LngLatLike, LngLatLike] |
  [number, number, number, number]

declare function setCamera(camera: CameraOptions): void
declare function viewportForBounds(bounds: LngLatBounds): Camera
</pre>
</div>
<ul class="org-ul">
<li>Input types tend to be broader than output types. Optional properties and union types are more common in parameter types than return types.</li>
<li>To reuse types between parameters and return types, introduce a canonical form (for return types) and a looser form (for parameters).</li>
</ul>
</div>
</div>
<div id="outline-container-orgb8993ff" class="outline-4">
<h4 id="orgb8993ff"><span class="section-number-4">1.5.3.</span> Item 30: Don't Repeat Type Information in Documentation</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>Consider including units in variable names if they aren't clear from the type (e.g., timeMS or temperatureC).</li>
</ul>
</div>
</div>
<div id="outline-container-orga2c8179" class="outline-4">
<h4 id="orga2c8179"><span class="section-number-4">1.5.4.</span> Item 31: Push Null Values to the Perimeter of Your Types</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">
<pre class="src src-typescript">function extent(nums: number[]) {
  let result: [number, number] | null = null
  for (const num in nums) {
    if (!result) {
      result = [num, num]
    } else {
      result = [Math.min(num, result[0]), Math.max(num, result[1])]
    }
  }
  return result
}

const range = extent([0, 1, 2])
if (range) {
  const [min, max] = range
  //...
}
const [min, max] = range!
</pre>
</div>

<div class="org-src-container">
<pre class="src src-typescript">class UserPosts {
  user: UserInfo
  posts: Post[]

  constructor(user: UserInfo, posts: Post[]) {
    this.user = user
    this.posts = posts
  }

  static async init(userId: string): Promise&lt;UserPosts&gt; {
    const [user, posts] = await Promise.all([
      fetchUser(userId),
      fetchPostsForUser(userId)
    ])
    return new UserPosts(user, posts)
  }

  getUserName() {
    return this.user.name
  }
}
</pre>
</div>

<ul class="org-ul">
<li>Avoid designs in which one value being <code>null</code> or not <code>null</code> is implicitly related to another value being <code>null</code> or not <code>null</code>.</li>
<li>Push <code>null</code> values to the perimeter of your API by making larger objects either <code>null</code> or fully non-null. This will make code clearer both for human readers and for the type checker.</li>
<li>Consider creating a fully non-null class and constructing it when all values are available.</li>
<li>While <code>strictNullChecks</code> may flag many issues in your code, it's indispensable for surfacing the behavior of functions with respet to null values.</li>
</ul>
</div>
</div>
<div id="outline-container-orgef27304" class="outline-4">
<h4 id="orgef27304"><span class="section-number-4">1.5.5.</span> Item 32: Prefer Unions of Interfaces to Interfaces of Unions</h4>
<div class="outline-text-4" id="text-1-5-5">
<ul class="org-ul">
<li>Interfaces with multiple properties that are union types are often a mistake because they obscure the relationships between these properties.</li>
<li>Unions of interfaces are more precise and can be understood by TypeScript.</li>
<li>Consider adding a "tag" to your structure to facilitate TypeScript's control flow analysis. Because they are so well supported, tagged unions are ubiquitous in TypeScript code.</li>
</ul>
</div>
</div>
<div id="outline-container-org4b4ce61" class="outline-4">
<h4 id="org4b4ce61"><span class="section-number-4">1.5.6.</span> Item 33: Prefer More Precise Alternatives to String Types</h4>
<div class="outline-text-4" id="text-1-5-6">
<div class="org-src-container">
<pre class="src src-typescript">function pluck&lt;T, K extends keyof T&gt;(records: T[], key: K): T[K][] {
  return records.map(record =&gt; record[key])
}
</pre>
</div>
<ul class="org-ul">
<li>Avoid "stringly typed" code. Prefer more appropriate types where not every <code>string</code> is a possibility.</li>
<li>Prefer a union of string literal types to <code>string</code> if that more accurately describes tE domain of a variable. You'll get stricter type checking and improve the development experience.</li>
<li>Prefer <code>keyof T</code> to <code>string</code> for function parameters that are expected to be properties of an object.</li>
</ul>
</div>
</div>
<div id="outline-container-org3617d29" class="outline-4">
<h4 id="org3617d29"><span class="section-number-4">1.5.7.</span> Item 34: Prefer Incomplete Types to Inaccurate Types</h4>
<div class="outline-text-4" id="text-1-5-7">
<ul class="org-ul">
<li>Avoid the uncanny valley of type safety: incorrect types are often worse than no types.</li>
<li>If you cannot model a type accurately, do not model it inaccurately! Acknowledge the gaps using <code>any</code> or <code>unknown</code>.</li>
<li>Pay attentation to error messages and autocomplete as you make typings increasingly precise. It's not just about correctness: developer experience matters, too.</li>
</ul>
</div>
</div>
<div id="outline-container-org6d6e6a6" class="outline-4">
<h4 id="org6d6e6a6"><span class="section-number-4">1.5.8.</span> Item 35: Generate Types from APIs and Specs, Not Data</h4>
<div class="outline-text-4" id="text-1-5-8">
<ul class="org-ul">
<li>Consider generating types for API calls and data formats to get type safety all the way to the edge of your code.</li>
<li>Prefer generating code from specs rather than data. Rare cases matter!</li>
</ul>
</div>
</div>
<div id="outline-container-orgce79041" class="outline-4">
<h4 id="orgce79041"><span class="section-number-4">1.5.9.</span> Item 36: Name Types Using the Language of Your Problem Domain</h4>
<div class="outline-text-4" id="text-1-5-9">
<ul class="org-ul">
<li>Reuse names from the domain of your problem where possible to increase the readability and level of abstraction of your code.</li>
<li>Avoid using different names for the same thing: make distinctions in names meaningful.</li>
</ul>
</div>
</div>
<div id="outline-container-orgaca5ce1" class="outline-4">
<h4 id="orgaca5ce1"><span class="section-number-4">1.5.10.</span> Item 37: Consider "Brands" for Nominal Typing</h4>
<div class="outline-text-4" id="text-1-5-10">
<div class="org-src-container">
<pre class="src src-typescript">type AbsolutePath = string &amp; { _brand: 'abs' }

function isAbsolutePath(path: string): path is AbsolutePath {
  return path.startsWith('/')
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-typescript">type SortedList&lt;T&gt; = T[] &amp; { _brand: 'sorted' }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-typescript">type Meters = number &amp; { _brand: 'meters' }
type Seconds = number &amp; { _brand: 'seconds' }

const meters = (m: number) =&gt; m as Meters
const seconds = (s: number) =&gt; s as Seconds
</pre>
</div>

<ul class="org-ul">
<li>TypeScript uses structural ("duck") typing, which can sometimes lead to surprising results. If you need nominal typing, consider attaching "brands" to your values to distinguish them.</li>
<li>In some cases you may be able to attach brands entirely in the type system, rather than at runtime. You can use this technique to model properties outside of TypeScript's type system.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class="links"><a href="#content">T</a><a href="index.html">H</a><a id="share-img">I</a><a href="20210629191000-000_index.html">0</a></div><script src="static/dom2img.min.js" type="text/javascript"></script><script src="static/x.js" type="text/javascript"></script>
</div>
</body>
</html>
