<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-01 Tue 11:15 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Effective Kotlin</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="static/x.css" type="text/css"/><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Effective Kotlin</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgd07a0b4">1. Introduction: Be pragmatic</a>
<ul>
<li><a href="#org58d8fee">1.1. The philosophy of Kotlin</a></li>
<li><a href="#org36dd43e">1.2. The purpose of this book</a></li>
<li><a href="#org9cdd617">1.3. For whom is this book written?</a></li>
<li><a href="#orgc7a06ea">1.4. Book design</a></li>
<li><a href="#org24ecc62">1.5. Chapters organization</a></li>
<li><a href="#org087a0fd">1.6. How should this book be read?</a></li>
<li><a href="#org1219a42">1.7. Labels</a></li>
<li><a href="#orgf64cb4f">1.8. Suggestions</a></li>
</ul>
</li>
<li><a href="#org650e7cd">2. Part 1: Good code</a>
<ul>
<li><a href="#orge55d98a">2.1. Chapter 1: Safety</a>
<ul>
<li><a href="#org046f4e8">2.1.1. Item 1: Limit mutability</a></li>
<li><a href="#org3558818">2.1.2. Item 2: Minimize the scope of variables</a></li>
<li><a href="#org4cf3600">2.1.3. Item 3: Eliminate platform types as soon as possible</a></li>
<li><a href="#org3319e99">2.1.4. Item 4: Do not expose inferred types</a></li>
<li><a href="#orgb7e2491">2.1.5. Item 5: Specify your expectations on arguments and state</a></li>
<li><a href="#org72511e9">2.1.6. Item 8: Handle nulls properly</a>
<ul>
<li><a href="#org17ef034">2.1.6.1. Handling nulls safely</a></li>
<li><a href="#org87431bd">2.1.6.2. Throw an error</a></li>
<li><a href="#org8339133">2.1.6.3. Avoiding meaningless nullability</a></li>
<li><a href="#org26ad704">2.1.6.4. <code>lateinit</code> property and <code>notNull</code> delegate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbaa510a">2.2. Chatper 2: Readability</a>
<ul>
<li><a href="#org26ea715">2.2.1. Item 11: Design for readability</a>
<ul>
<li><a href="#orgd34e130">2.2.1.1. Reducing cognitive load</a></li>
<li><a href="#org210025c">2.2.1.2. Do not get extreme</a></li>
<li><a href="#org8c0065b">2.2.1.3. Conventions</a></li>
</ul>
</li>
<li><a href="#org8ddf3ba">2.2.2. Item 12: Operator meaning should be consistent with its function name</a></li>
<li><a href="#orgf1857b7">2.2.3. Item 16: Properties should represent state, not behavior</a></li>
<li><a href="#orgeb70a4e">2.2.4. Item 17: Consider naming arguments</a></li>
<li><a href="#org6928020">2.2.5. Item 18: Respect coding conventions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org78abdf7">3. Part 2: Code design</a>
<ul>
<li><a href="#orgd50c606">3.1. Chapter 3: Reusability</a>
<ul>
<li><a href="#org62e7d9d">3.1.1. Item 19: Do not repeat knowledge</a></li>
<li><a href="#org559541d">3.1.2. Item 20: Do not repeat common algorithms</a></li>
<li><a href="#org15a19c6">3.1.3. Item 21: Use Property delegation to extract common property patterns</a></li>
<li><a href="#org25449f3">3.1.4. Item 23: Avoid shadowing type parameters</a></li>
<li><a href="#org2839338">3.1.5. Item 24: Consider variance for generic types</a></li>
<li><a href="#org5348a76">3.1.6. Item 25: Reuse between different platforms by extracting common modules</a></li>
</ul>
</li>
<li><a href="#org271eff4">3.2. Chapter 4: Abstraction design</a>
<ul>
<li><a href="#orgc6540bb">3.2.1. Item 26: Each function should be written in terms of a single level of abstraction</a></li>
<li><a href="#org4cdd360">3.2.2. Item 27: Use abstraction to protect code against changes</a>
<ul>
<li><a href="#org05bf562">3.2.2.1. Abstractions give freedom</a></li>
<li><a href="#org1a96da9">3.2.2.2. Problems with abstraction</a></li>
</ul>
</li>
<li><a href="#orgb8b6a24">3.2.3. Item 28: Specify API stability</a></li>
<li><a href="#org17087b2">3.2.4. Item 29: Consider wrapping external API</a></li>
<li><a href="#org541849d">3.2.5. Item 30: Minimize elements visibility</a></li>
<li><a href="#org384c33d">3.2.6. Item 31: Define contract with documentation</a></li>
<li><a href="#org1cdaff1">3.2.7. Item 32: Respect abstraction contracts</a></li>
</ul>
</li>
<li><a href="#org1e42b68">3.3. Chapter 5: Object creation</a>
<ul>
<li><a href="#org846e7e4">3.3.1. Item 33: Consider factory functions instead of constructors</a>
<ul>
<li><a href="#orga78a6d7">3.3.1.1. Companion object factory function</a></li>
<li><a href="#org5ca2f11">3.3.1.2. Extension factory functions</a></li>
<li><a href="#org0710240">3.3.1.3. Top-level functions</a></li>
<li><a href="#org47534dc">3.3.1.4. Fake constructors</a></li>
<li><a href="#orga571911">3.3.1.5. Methods on a factory class</a></li>
</ul>
</li>
<li><a href="#org5e16a43">3.3.2. Item 34: Consider a primary constructor with named optional arguments</a></li>
<li><a href="#org93a4ae7">3.3.3. Item 35: Consider defining a DSL for complex object creation</a></li>
</ul>
</li>
<li><a href="#orgf6e9b18">3.4. Chapter 6: Class design</a>
<ul>
<li><a href="#org03e463f">3.4.1. Item 36: Prefer composition over inheritance</a></li>
<li><a href="#org62425d6">3.4.2. Item 37: Use the data modifier to represent a bundle of data</a></li>
<li><a href="#orgff797de">3.4.3. Item 38: Use function types instead of interfaces to pass operations and actions</a></li>
<li><a href="#org1fe9868">3.4.4. Item 39: Prefer class hierarchies to tagged classes</a></li>
<li><a href="#org8f133bd">3.4.5. Item 40: Respect the contract of <code>equals</code></a>
<ul>
<li><a href="#org16c684e">3.4.5.1. Equality</a></li>
<li><a href="#org64678dc">3.4.5.2. Why do we need equals?</a></li>
<li><a href="#orgf9a3920">3.4.5.3. When to implement <code>equals</code> ourselves</a></li>
</ul>
</li>
<li><a href="#orgd6e9118">3.4.6. Item 41: Respect the contract of <code>hashCode</code></a>
<ul>
<li><a href="#orgd614d1b">3.4.6.1. Hash table</a></li>
<li><a href="#org5aa595a">3.4.6.2. Problem with mutability</a></li>
</ul>
</li>
<li><a href="#org441759a">3.4.7. Item 42: Respect the contract of <code>compareTo</code></a></li>
<li><a href="#org288ec49">3.4.8. Item 43: Consider extracting non-essential parts of your API into extensions</a></li>
<li><a href="#org83068ef">3.4.9. Item 44: Avoid member extensions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org50be904">4. Part 3: Efficiency</a>
<ul>
<li><a href="#org67ab242">4.1. Chapter 7: Make it cheap</a>
<ul>
<li><a href="#orgd741a60">4.1.1. Item 46: Use inline modifier for functions with parameters of functional types</a>
<ul>
<li><a href="#org4d0f878">4.1.1.1. A type argument can be reified</a></li>
<li><a href="#org052e43e">4.1.1.2. Functions with functional parameters are faster when they are inlined</a></li>
<li><a href="#org17d79d5">4.1.1.3. Non-local return is allowed</a></li>
<li><a href="#org87c8898">4.1.1.4. Costs of inline modifier</a></li>
<li><a href="#org8ad4730">4.1.1.5. Crossinline and noinline</a></li>
</ul>
</li>
<li><a href="#org71c9e01">4.1.2. Item 47: Consider using inline classes</a>
<ul>
<li><a href="#orgea91c48">4.1.2.1. Indicate unit of measure</a></li>
<li><a href="#orgb2c5246">4.1.2.2. Protect us from type misuse</a></li>
<li><a href="#orgd2b72f5">4.1.2.3. Inline classes and interfaces</a></li>
<li><a href="#orge9f3eef">4.1.2.4. Typealias</a></li>
</ul>
</li>
<li><a href="#org57e9eb6">4.1.3. Item 48: Eliminate obsolete object references</a></li>
</ul>
</li>
<li><a href="#org781d810">4.2. Chapter 8: Efficient collection processing</a>
<ul>
<li><a href="#org82c90e1">4.2.1. Item 50: Limit the number of operations</a></li>
<li><a href="#orge838233">4.2.2. Item 51: Consider Arrays with primitives for performance-critical processing</a></li>
<li><a href="#orgc0c4c8e">4.2.3. Item 52: Consider using mutable collections</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<dl class="org-dl">
<dt>link</dt><dd><a href="20210505063407-kotlin.html#ID-5F0F4BA6-E79A-4214-9DD7-CD79DC775854">Kotlin</a></dd>
<dt>start</dt><dd><span class="timestamp-wrapper"><span class="timestamp">&lt;2022-08-17 Wed 10:09&gt;</span></span></dd>
</dl>

<div id="outline-container-orgd07a0b4" class="outline-2">
<h2 id="orgd07a0b4"><span class="section-number-2">1.</span> Introduction: Be pragmatic</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org58d8fee" class="outline-3">
<h3 id="org58d8fee"><span class="section-number-3">1.1.</span> The philosophy of Kotlin</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The central point of Kotlin's philosophy is pragmatism. This means that in the end, all choices need to serve business needs, like:
</p>
<ul class="org-ul">
<li><i>Productivity</i>: application production is fast.</li>
<li><i>Scalability</i>: with application growth, its development does not become more expensive. It may even get cheaper.</li>
<li><i>Maintainability</i>: maintenance is easy.</li>
<li><i>Reliability</i>: applications behave as expected, and there are fewer errors.</li>
<li><i>Efficiency</i>: the application runs fast and needs fewer resources (memory, processor, etc.).</li>
</ul>
</div>
</div>
<div id="outline-container-org36dd43e" class="outline-3">
<h3 id="org36dd43e"><span class="section-number-3">1.2.</span> The purpose of this book</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The main goal of this book is to explain how to use different Kotlin features to achieve safe, readable, scalable, and efficient code.
</p>

<p>
This book concentrates on higher-level good practices that come from authorities, the Kotlin creators, and from my experience as a developer, consultant, and trainer for international companies worldwide.
</p>
</div>
</div>
<div id="outline-container-org9cdd617" class="outline-3">
<h3 id="org9cdd617"><span class="section-number-3">1.3.</span> For whom is this book written?</h3>
<div class="outline-text-3" id="text-1-3">
<p>
I will assume that even experienced developers might not know some features. This is why I explain some concepts like:
</p>
<ul class="org-ul">
<li>Property</li>
<li>Platform type</li>
<li>Named arguments</li>
<li>Property delegation</li>
<li>DSL creation</li>
<li>Inline classes and functions</li>
</ul>
</div>
</div>
<div id="outline-container-orgc7a06ea" class="outline-3">
<h3 id="orgc7a06ea"><span class="section-number-3">1.4.</span> Book design</h3>
</div>
<div id="outline-container-org24ecc62" class="outline-3">
<h3 id="org24ecc62"><span class="section-number-3">1.5.</span> Chapters organization</h3>
</div>
<div id="outline-container-org087a0fd" class="outline-3">
<h3 id="org087a0fd"><span class="section-number-3">1.6.</span> How should this book be read?</h3>
</div>
<div id="outline-container-org1219a42" class="outline-3">
<h3 id="org1219a42"><span class="section-number-3">1.7.</span> Labels</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>Not Kotlin-specific</li>
<li>Basics</li>
<li>Edu</li>
</ul>
</div>
</div>
<div id="outline-container-orgf64cb4f" class="outline-3">
<h3 id="orgf64cb4f"><span class="section-number-3">1.8.</span> Suggestions</h3>
</div>
</div>
<div id="outline-container-org650e7cd" class="outline-2">
<h2 id="org650e7cd"><span class="section-number-2">2.</span> Part 1: Good code</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orge55d98a" class="outline-3">
<h3 id="orge55d98a"><span class="section-number-3">2.1.</span> Chapter 1: Safety</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org046f4e8" class="outline-4">
<h4 id="org046f4e8"><span class="section-number-4">2.1.1.</span> Item 1: Limit mutability</h4>
</div>
<div id="outline-container-org3558818" class="outline-4">
<h4 id="org3558818"><span class="section-number-4">2.1.2.</span> Item 2: Minimize the scope of variables</h4>
</div>
<div id="outline-container-org4cf3600" class="outline-4">
<h4 id="org4cf3600"><span class="section-number-4">2.1.3.</span> Item 3: Eliminate platform types as soon as possible</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
<i>Platform type</i> - a type that comes from another language and has unknown nullability.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="font-weight: bold;">public</span> <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">UserRepo</span> {
  <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">User</span> <span style="font-weight: bold;">getUser</span>() {
    <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">...</span>
  }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kotlin">val repo = UserRepo()
val user1 = repo.user        // Type of user1 is User!
val user2: User = repo.user  // Type of user2 is User
val user3: User? = repo.user // Type of user3 is User?
</pre>
</div>

<p>
What're the differences between <code>User!</code> and <code>User</code>?
</p>
</div>
</div>
<div id="outline-container-org3319e99" class="outline-4">
<h4 id="org3319e99"><span class="section-number-4">2.1.4.</span> Item 4: Do not expose inferred types</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
If we are not sure about the type, we should specify it. In an external API, we should always specify types. We cannot let them be changed by accident. Inferred types can be too restrictive or can too easily change when our project envolves.
</p>
</div>
</div>
<div id="outline-container-orgb7e2491" class="outline-4">
<h4 id="orgb7e2491"><span class="section-number-4">2.1.5.</span> Item 5: Specify your expectations on arguments and state</h4>
<div class="outline-text-4" id="text-2-1-5">
<ul class="org-ul">
<li><i>require</i> block: a universal way to specify expectations on arguments.</li>
<li><i>check</i> block: a universal way to specify expectations on the state.</li>
<li><i>assert</i> block: a universal way to check if something is true in testing mode for our own implementation.</li>
<li>Elvis operator(<code>?:</code>) with <code>return</code> or <code>throw</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-org72511e9" class="outline-4">
<h4 id="org72511e9"><span class="section-number-4">2.1.6.</span> Item 8: Handle nulls properly</h4>
<div class="outline-text-4" id="text-2-1-6">
</div>
<div id="outline-container-org17ef034" class="outline-5">
<h5 id="org17ef034"><span class="section-number-5">2.1.6.1.</span> Handling nulls safely</h5>
</div>
<div id="outline-container-org87431bd" class="outline-5">
<h5 id="org87431bd"><span class="section-number-5">2.1.6.2.</span> Throw an error</h5>
</div>
<div id="outline-container-org8339133" class="outline-5">
<h5 id="org8339133"><span class="section-number-5">2.1.6.3.</span> Avoiding meaningless nullability</h5>
</div>
<div id="outline-container-org26ad704" class="outline-5">
<h5 id="org26ad704"><span class="section-number-5">2.1.6.4.</span> <code>lateinit</code> property and <code>notNull</code> delegate</h5>
</div>
</div>
</div>
<div id="outline-container-orgbaa510a" class="outline-3">
<h3 id="orgbaa510a"><span class="section-number-3">2.2.</span> Chatper 2: Readability</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org26ea715" class="outline-4">
<h4 id="org26ea715"><span class="section-number-4">2.2.1.</span> Item 11: Design for readability</h4>
<div class="outline-text-4" id="text-2-2-1">
</div>
<div id="outline-container-orgd34e130" class="outline-5">
<h5 id="orgd34e130"><span class="section-number-5">2.2.1.1.</span> Reducing cognitive load</h5>
</div>
<div id="outline-container-org210025c" class="outline-5">
<h5 id="org210025c"><span class="section-number-5">2.2.1.2.</span> Do not get extreme</h5>
</div>
<div id="outline-container-org8c0065b" class="outline-5">
<h5 id="org8c0065b"><span class="section-number-5">2.2.1.3.</span> Conventions</h5>
</div>
</div>
<div id="outline-container-org8ddf3ba" class="outline-4">
<h4 id="org8ddf3ba"><span class="section-number-4">2.2.2.</span> Item 12: Operator meaning should be consistent with its function name</h4>
</div>
<div id="outline-container-orgf1857b7" class="outline-4">
<h4 id="orgf1857b7"><span class="section-number-4">2.2.3.</span> Item 16: Properties should represent state, not behavior</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
Properties are essentially functions, we can make extension properties as well:
</p>
<div class="org-src-container">
<pre class="src src-kotlin">val Context.preferences: SharedPreferences
  get() = PreferencesManager
    .getDefaultSharedPreferences(this)
</pre>
</div>

<p>
<b>Properties represent accessors, not fields.</b> The general rule is that <b>we should use them only to represent or set state, and no other logic should be involved.</b> If I would define a property as a function, would I prefix it with get/set? If not, it should rather not be a property.
</p>

<p>
The most typical situations when we should not use properties, and we should use functions instead:
</p>
<ul class="org-ul">
<li><b>Operation is computationally expensive or has computational complexity higher than O(1)</b></li>
<li><b>It involves business logic</b></li>
<li><b>It is not deterministic</b>: Calling the member twice in succession produces different results.</li>
<li><b>It is a conversion, such as</b> <code>Int.toDouble()</code></li>
<li><b>Getters should not change property state</b></li>
</ul>
</div>
</div>
<div id="outline-container-orgeb70a4e" class="outline-4">
<h4 id="orgeb70a4e"><span class="section-number-4">2.2.4.</span> Item 17: Consider naming arguments</h4>
</div>
<div id="outline-container-org6928020" class="outline-4">
<h4 id="org6928020"><span class="section-number-4">2.2.5.</span> Item 18: Respect coding conventions</h4>
</div>
</div>
</div>
<div id="outline-container-org78abdf7" class="outline-2">
<h2 id="org78abdf7"><span class="section-number-2">3.</span> Part 2: Code design</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgd50c606" class="outline-3">
<h3 id="orgd50c606"><span class="section-number-3">3.1.</span> Chapter 3: Reusability</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org62e7d9d" class="outline-4">
<h4 id="org62e7d9d"><span class="section-number-4">3.1.1.</span> Item 19: Do not repeat knowledge</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
The biggest enemy of changes is knowledge repetition.
</p>

<p>
Are they more likely going to change together or separately?
</p>
</div>
</div>
<div id="outline-container-org559541d" class="outline-4">
<h4 id="org559541d"><span class="section-number-4">3.1.2.</span> Item 20: Do not repeat common algorithms</h4>
</div>
<div id="outline-container-org15a19c6" class="outline-4">
<h4 id="org15a19c6"><span class="section-number-4">3.1.3.</span> Item 21: Use Property delegation to extract common property patterns</h4>
<div class="outline-text-4" id="text-3-1-3">
<div class="org-src-container">
<pre class="src src-kotlin">var token: String? by LoggingProperty(null)
var attempts: Int by LoggingProperty(0)

private class LoggingProperty&lt;T&gt;(var value: T) {
  operator fun getValue(
    thisRef: Any?,
    prop: KProperty&lt;*&gt;
  ): T {
    print("${prop.name} returned value $value")
    return value
  }

  operator fun setValue(
    thisRef: Any?,
    prop: KProperty&lt;*&gt;,
    newValue: T
  ) {
    print("${prop.name} changed from ${value} to ${newValue}")
    value = newValue
  }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-kotlin">@Suppress("UNCHECKED_CAST")
  /**
   * @param key must be exist, otherwise will throw exception
   */
  class ArgExtraDelegate&lt;T&gt;(val key: String) {
    operator fun getValue(thisRef: Activity, property: KProperty&lt;*&gt;): T {
      return thisRef.intent.extras!!.get(key) as T
    }
  }

  /**
   * @param key must be exist, otherwise will throw exception
   */
  fun &lt;T&gt; argExtra(key: String) = ArgExtraDelegate&lt;T&gt;(key)

  private const val EXTRA_IS_CREATING = "isCreating"
  private val isCreating: Boolean by argExtra(EXTRA_IS_CREATING)
</pre>
</div>
</div>
</div>
<div id="outline-container-org25449f3" class="outline-4">
<h4 id="org25449f3"><span class="section-number-4">3.1.4.</span> Item 23: Avoid shadowing type parameters</h4>
</div>
<div id="outline-container-org2839338" class="outline-4">
<h4 id="org2839338"><span class="section-number-4">3.1.5.</span> Item 24: Consider variance for generic types</h4>
</div>
<div id="outline-container-org5348a76" class="outline-4">
<h4 id="org5348a76"><span class="section-number-4">3.1.6.</span> Item 25: Reuse between different platforms by extracting common modules</h4>
</div>
</div>
<div id="outline-container-org271eff4" class="outline-3">
<h3 id="org271eff4"><span class="section-number-3">3.2.</span> Chapter 4: Abstraction design</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Car metaphor
</p>
</div>
<div id="outline-container-orgc6540bb" class="outline-4">
<h4 id="orgc6540bb"><span class="section-number-4">3.2.1.</span> Item 26: Each function should be written in terms of a single level of abstraction</h4>
</div>
<div id="outline-container-org4cdd360" class="outline-4">
<h4 id="org4cdd360"><span class="section-number-4">3.2.2.</span> Item 27: Use abstraction to protect code against changes</h4>
<div class="outline-text-4" id="text-3-2-2">
</div>
<div id="outline-container-org05bf562" class="outline-5">
<h5 id="org05bf562"><span class="section-number-5">3.2.2.1.</span> Abstractions give freedom</h5>
<div class="outline-text-5" id="text-3-2-2-1">
<ul class="org-ul">
<li>Extracting constant</li>
<li>Wrapping behavior into a function</li>
<li>Wrapping function into a class</li>
<li>Hiding a class behind an interface</li>
<li>Wrapping universal objects into specialistic</li>
<li>Using generic type parameters</li>
<li>Extracting inner classes</li>
<li>Restricting creation, for instance by forcing object creation via factory method</li>
</ul>
</div>
</div>
<div id="outline-container-org1a96da9" class="outline-5">
<h5 id="org1a96da9"><span class="section-number-5">3.2.2.2.</span> Problems with abstraction</h5>
</div>
</div>
<div id="outline-container-orgb8b6a24" class="outline-4">
<h4 id="orgb8b6a24"><span class="section-number-4">3.2.3.</span> Item 28: Specify API stability</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Version names, documentation, and annotations.
</p>
</div>
</div>
<div id="outline-container-org17087b2" class="outline-4">
<h4 id="org17087b2"><span class="section-number-4">3.2.4.</span> Item 29: Consider wrapping external API</h4>
</div>
<div id="outline-container-org541849d" class="outline-4">
<h4 id="org541849d"><span class="section-number-4">3.2.5.</span> Item 30: Minimize elements visibility</h4>
</div>
<div id="outline-container-org384c33d" class="outline-4">
<h4 id="org384c33d"><span class="section-number-4">3.2.6.</span> Item 31: Define contract with documentation</h4>
<div class="outline-text-4" id="text-3-2-6">
<p>
When the behavior is not documented and the element name is not clear, developers will depend on current implementation instead of on the abstraction we intended to create.
</p>

<p>
When a contract is well specified, creators do not need to worry about how the class is used, and users do not need to worry about how something is implemented under the hood.
</p>
</div>
</div>
<div id="outline-container-org1cdaff1" class="outline-4">
<h4 id="org1cdaff1"><span class="section-number-4">3.2.7.</span> Item 32: Respect abstraction contracts</h4>
</div>
</div>
<div id="outline-container-org1e42b68" class="outline-3">
<h3 id="org1e42b68"><span class="section-number-3">3.3.</span> Chapter 5: Object creation</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org846e7e4" class="outline-4">
<h4 id="org846e7e4"><span class="section-number-4">3.3.1.</span> Item 33: Consider factory functions instead of constructors</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>Unlike constructors, functions have names.</li>
<li>Unlike constructors, functions can return an object of any subtype of their return type.</li>
<li>Unlike constructors, functions are not required to create a new object each time they're invoked.</li>
<li>Factory functions can provide objects that might not yet exist.</li>
<li>When we define a factory function outside of an object, we can control its visibility.</li>
<li>Factory functions can be inline and so their type parameters can be reified.</li>
<li>Factory functions can construct objects which might otherwise be complicated to construct.</li>
<li>A constructor needs to immediately call a constructor of a superclass or a primary constructor. When we use factory functions, we can postpone constructor usage.</li>
</ul>

<p>
Factory functions are mainly a competition to secondary constructors.
</p>
</div>
<div id="outline-container-orga78a6d7" class="outline-5">
<h5 id="orga78a6d7"><span class="section-number-5">3.3.1.1.</span> Companion object factory function</h5>
<div class="outline-text-5" id="text-3-3-1-1">
<ul class="org-ul">
<li><code>from</code>: A type-conversion function that takes a single parameter and returns a corresponding instance of the same type, for example: <code>val date: Date = Date.from(instant)</code></li>
<li><code>of</code>: An aggregation function that takes multiple parameters and returns an instance of the same type that incorporates them, for example: <code>val faceCards: Set&lt;Rank&gt; = EnumSet.of(JACK, QUEEN, KING)</code></li>
<li><code>valueOf</code>: A more verbose alternative to <code>from</code> and <code>of</code>, for example: <code>val prime: BigInteger = BigInteger.valueOf(Integer.MAX_VALUE)</code></li>
<li><code>instance</code> or <code>getInstance</code>: Used in singletons to get the only instance.</li>
<li><code>createInstance</code> or <code>newInstance</code>: Like <code>getInstance</code>, but this function guarantees that each call returns a new instance.</li>
<li><code>getType</code>: Like <code>getInstance</code>, but used if the factory function is in a different class. Type is the type of object returned by the factory function, for example: <code>val fs: FileStore = Files.getFileStore(path)</code></li>
<li><code>newType</code>: Like <code>newInstance</code>, but used if the factory function is in a different class, for example: <code>val br: BufferedReader = Files.newBufferedReader(path)</code></li>
</ul>
</div>
</div>
<div id="outline-container-org5ca2f11" class="outline-5">
<h5 id="org5ca2f11"><span class="section-number-5">3.3.1.2.</span> Extension factory functions</h5>
<div class="outline-text-5" id="text-3-3-1-2">
<div class="org-src-container">
<pre class="src src-kotlin">interface Tool {
  companion object { /*...*/ }
}

fun Tool.Companion.create( /*...*/ ): Tool { /*...*/ }

Tool.create( /*...*/ )
</pre>
</div>
</div>
</div>
<div id="outline-container-org0710240" class="outline-5">
<h5 id="org0710240"><span class="section-number-5">3.3.1.3.</span> Top-level functions</h5>
<div class="outline-text-5" id="text-3-3-1-3">
<p>
<code>listOf</code>, <code>setOf</code> and <code>mapOf</code>.
</p>
</div>
</div>
<div id="outline-container-org47534dc" class="outline-5">
<h5 id="org47534dc"><span class="section-number-5">3.3.1.4.</span> Fake constructors</h5>
<div class="outline-text-5" id="text-3-3-1-4">
<p>
Constructors in Kotlin are used the same way as top-level functions.
</p>
<div class="org-src-container">
<pre class="src src-kotlin">class A
val a = A()

val reference: () -&gt; A = ::A
</pre>
</div>
</div>
</div>
<div id="outline-container-orga571911" class="outline-5">
<h5 id="orga571911"><span class="section-number-5">3.3.1.5.</span> Methods on a factory class</h5>
<div class="outline-text-5" id="text-3-3-1-5">
<div class="org-src-container">
<pre class="src src-kotlin">data class Student(
  val id: Int,
  val name: String,
  val surname: String
)

class StudentFactory {
  private var nextId = 0
  fun next(name: String, surname: String) = Student(nextId++, name, surname)
}

val factory = StudentFactory()
val student1 = factory.next("John", "Doe")
val student2 = factory.next("Jane", "Wojda")
</pre>
</div>

<p>
Factory classes can have properties and those properties can be used to optimize object creation. When we can hold a state we can introduce different kinds of optimizations or capabilities. We can for instance use caching, or speed up object creation by duplicating previously created objects.
</p>
</div>
</div>
</div>
<div id="outline-container-org5e16a43" class="outline-4">
<h4 id="org5e16a43"><span class="section-number-4">3.3.2.</span> Item 34: Consider a primary constructor with named optional arguments</h4>
<div class="outline-text-4" id="text-3-3-2">
<div class="org-src-container">
<pre class="src src-kotlin">val dialog = context.alert(R.string.fire_missiles) {
  positiveButton(R.string.fire) { fire() }
  negativeButton { cancel() }
}

val route = router {
  "/home" directsTo ::showHome
  "/settings" directsTo ::showSettings
}
</pre>
</div>

<p>
These kinds of DSL builders are generally preferred over classic builder pattern, since they give more flexibility and cleaner notation.
</p>
</div>
</div>
<div id="outline-container-org93a4ae7" class="outline-4">
<h4 id="org93a4ae7"><span class="section-number-4">3.3.3.</span> Item 35: Consider defining a DSL for complex object creation</h4>
</div>
</div>
<div id="outline-container-orgf6e9b18" class="outline-3">
<h3 id="orgf6e9b18"><span class="section-number-3">3.4.</span> Chapter 6: Class design</h3>
<div class="outline-text-3" id="text-3-4">
</div>
<div id="outline-container-org03e463f" class="outline-4">
<h4 id="org03e463f"><span class="section-number-4">3.4.1.</span> Item 36: Prefer composition over inheritance</h4>
</div>
<div id="outline-container-org62425d6" class="outline-4">
<h4 id="org62425d6"><span class="section-number-4">3.4.2.</span> Item 37: Use the data modifier to represent a bundle of data</h4>
</div>
<div id="outline-container-orgff797de" class="outline-4">
<h4 id="orgff797de"><span class="section-number-4">3.4.3.</span> Item 38: Use function types instead of interfaces to pass operations and actions</h4>
</div>
<div id="outline-container-org1fe9868" class="outline-4">
<h4 id="org1fe9868"><span class="section-number-4">3.4.4.</span> Item 39: Prefer class hierarchies to tagged classes</h4>
<div class="outline-text-4" id="text-3-4-4">
<p>
sealed classes
</p>
</div>
</div>
<div id="outline-container-org8f133bd" class="outline-4">
<h4 id="org8f133bd"><span class="section-number-4">3.4.5.</span> Item 40: Respect the contract of <code>equals</code></h4>
<div class="outline-text-4" id="text-3-4-5">
</div>
<div id="outline-container-org16c684e" class="outline-5">
<h5 id="org16c684e"><span class="section-number-5">3.4.5.1.</span> Equality</h5>
<div class="outline-text-5" id="text-3-4-5-1">
<p>
In kotlin, there are two types of equality:
</p>
<ul class="org-ul">
<li>Structural equality: checked by the <code>equals</code> method or <code>==</code> operator (and its negated counterpart <code>!=</code>) which is based on the <code>equals</code> method. <code>a==b</code> translates to <code>a.equals(b)</code> when a is not nullable, or otherwise to <code>a?.equals(b) ?: (b===null)</code>.</li>
<li>Referential equality: checked by the <code>===</code> operator (and its negated counterpart <code>!==</code>), returns <code>true</code> when both sides point to the same object.</li>
</ul>
</div>
</div>
<div id="outline-container-org64678dc" class="outline-5">
<h5 id="org64678dc"><span class="section-number-5">3.4.5.2.</span> Why do we need equals?</h5>
<div class="outline-text-5" id="text-3-4-5-2">
<p>
The default implementation of <code>equals</code> coming from <code>Any</code> checks if another object is exactly the same instance. Just like referential equality (<code>===</code>). It means that every object by default is unique.
</p>
</div>
</div>
<div id="outline-container-orgf9a3920" class="outline-5">
<h5 id="orgf9a3920"><span class="section-number-5">3.4.5.3.</span> When to implement <code>equals</code> ourselves</h5>
<div class="outline-text-5" id="text-3-4-5-3">
<ul class="org-ul">
<li>We need its logic to differ from the default one</li>
<li>We need to compare only a subset of properties</li>
<li>We do not want our object to be a data class or properties we need to compare are not in the primary constructor</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd6e9118" class="outline-4">
<h4 id="orgd6e9118"><span class="section-number-4">3.4.6.</span> Item 41: Respect the contract of <code>hashCode</code></h4>
<div class="outline-text-4" id="text-3-4-6">
</div>
<div id="outline-container-orgd614d1b" class="outline-5">
<h5 id="orgd614d1b"><span class="section-number-5">3.4.6.1.</span> Hash table</h5>
</div>
<div id="outline-container-org5aa595a" class="outline-5">
<h5 id="org5aa595a"><span class="section-number-5">3.4.6.2.</span> Problem with mutability</h5>
<div class="outline-text-5" id="text-3-4-6-2">
<p>
A hash is calculated for an element only when this element is added.
</p>
</div>
</div>
</div>
<div id="outline-container-org441759a" class="outline-4">
<h4 id="org441759a"><span class="section-number-4">3.4.7.</span> Item 42: Respect the contract of <code>compareTo</code></h4>
<div class="outline-text-4" id="text-3-4-7">
<div class="org-src-container">
<pre class="src src-kotlin">class User(val name: String, val surname: String)
val users = listOf&lt;User&gt;(/* ... */)
users.sortedBy { it.surname }
users.sortedWith(compareBy({ it.surname }, { it.name }))
</pre>
</div>
</div>
</div>
<div id="outline-container-org288ec49" class="outline-4">
<h4 id="org288ec49"><span class="section-number-4">3.4.8.</span> Item 43: Consider extracting non-essential parts of your API into extensions</h4>
<div class="outline-text-4" id="text-3-4-8">
<p>
The biggest difference between members and extensions in terms of use is that <b>extensions need to be imported separately</b>.
</p>

<p>
Extenstions are <b>not virtual</b>, they cannot be redefined in derived classes.
</p>

<p>
We define extensions <b>on types, not on classes</b>. For instance, we can define an extension on a nullable or a concrete substitution of a generic type.
</p>
<div class="org-src-container">
<pre class="src src-kotlin">fun Iterable&lt;Int&gt;.sum(): Int {
    var sum = 0
    for (i in this) {
        sum += i
    }
    return sum
}
</pre>
</div>
<p>
Extensions are <b>not listed as members in the class reference</b>. This is why they are not considered by annotation processors and why, when we process a class using annotation processing, we cannot extract elements that should be processed into extension functions.
</p>
</div>
</div>
<div id="outline-container-org83068ef" class="outline-4">
<h4 id="org83068ef"><span class="section-number-4">3.4.9.</span> Item 44: Avoid member extensions</h4>
<div class="outline-text-4" id="text-3-4-9">
<div class="org-src-container">
<pre class="src src-kotlin">// Bad practice, do not do this
class PhoneBookIncorrect {
  // ...

  fun String.isPhoneNumber() =
    length == 11 &amp;&amp; all { it.isDigit() }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org50be904" class="outline-2">
<h2 id="org50be904"><span class="section-number-2">4.</span> Part 3: Efficiency</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org67ab242" class="outline-3">
<h3 id="org67ab242"><span class="section-number-3">4.1.</span> Chapter 7: Make it cheap</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-orgd741a60" class="outline-4">
<h4 id="orgd741a60"><span class="section-number-4">4.1.1.</span> Item 46: Use inline modifier for functions with parameters of functional types</h4>
<div class="outline-text-4" id="text-4-1-1">
</div>
<div id="outline-container-org4d0f878" class="outline-5">
<h5 id="org4d0f878"><span class="section-number-5">4.1.1.1.</span> A type argument can be reified</h5>
<div class="outline-text-5" id="text-4-1-1-1">
<p>
Function calls are replaced with its body, so type parameters uses can be replaced with type arguments, by using the <code>reified</code> modifier:
</p>
<div class="org-src-container">
<pre class="src src-kotlin">inline fun &lt;reified T&gt; printTypeName() {
  print(T::class.simpleName)
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org052e43e" class="outline-5">
<h5 id="org052e43e"><span class="section-number-5">4.1.1.2.</span> Functions with functional parameters are faster when they are inlined</h5>
</div>
<div id="outline-container-org17d79d5" class="outline-5">
<h5 id="org17d79d5"><span class="section-number-5">4.1.1.3.</span> Non-local return is allowed</h5>
</div>
<div id="outline-container-org87c8898" class="outline-5">
<h5 id="org87c8898"><span class="section-number-5">4.1.1.4.</span> Costs of inline modifier</h5>
<div class="outline-text-5" id="text-4-1-1-4">
<ul class="org-ul">
<li>Inline functions cannot be recursive.</li>
<li>Inline functions cannot be elements with more restrictive visibility.</li>
</ul>
</div>
</div>
<div id="outline-container-org8ad4730" class="outline-5">
<h5 id="org8ad4730"><span class="section-number-5">4.1.1.5.</span> Crossinline and noinline</h5>
</div>
</div>
<div id="outline-container-org71c9e01" class="outline-4">
<h4 id="org71c9e01"><span class="section-number-4">4.1.2.</span> Item 47: Consider using inline classes</h4>
<div class="outline-text-4" id="text-4-1-2">
</div>
<div id="outline-container-orgea91c48" class="outline-5">
<h5 id="orgea91c48"><span class="section-number-5">4.1.2.1.</span> Indicate unit of measure</h5>
<div class="outline-text-5" id="text-4-1-2-1">
<div class="org-src-container">
<pre class="src src-kotlin">inline class Minutes(val minutes: Int) {
  fun toMillis(): Millis = Millis(minutes * 60_000)
}

inline class Millis(val milliseconds: Int) {
  // ...
}

inline val Int.min get() = Minutes(this)
inline val Int.ms get() = Millis(this)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb2c5246" class="outline-5">
<h5 id="orgb2c5246"><span class="section-number-5">4.1.2.2.</span> Protect us from type misuse</h5>
</div>
<div id="outline-container-orgd2b72f5" class="outline-5">
<h5 id="orgd2b72f5"><span class="section-number-5">4.1.2.3.</span> Inline classes and interfaces</h5>
</div>
<div id="outline-container-orge9f3eef" class="outline-5">
<h5 id="orge9f3eef"><span class="section-number-5">4.1.2.4.</span> Typealias</h5>
</div>
</div>
<div id="outline-container-org57e9eb6" class="outline-4">
<h4 id="org57e9eb6"><span class="section-number-4">4.1.3.</span> Item 48: Eliminate obsolete object references</h4>
</div>
</div>
<div id="outline-container-org781d810" class="outline-3">
<h3 id="org781d810"><span class="section-number-3">4.2.</span> Chapter 8: Efficient collection processing</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org82c90e1" class="outline-4">
<h4 id="org82c90e1"><span class="section-number-4">4.2.1.</span> Item 50: Limit the number of operations</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">
<pre class="src src-kotlin">class Student(val name: String?)

fun List&lt;Student&gt;.getNames(): List&lt;String&gt; = this.mapNotNull { it.name }
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Instead of:</th>
<th scope="col" class="org-left">Use:</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">.filter { it != null}</td>
<td class="org-left">.filterNotNull()</td>
</tr>

<tr>
<td class="org-left">.map { it!! }</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">.map { &lt;Transformation&gt; }</td>
<td class="org-left">.mapNotNull { &lt;Transformation&gt; }</td>
</tr>

<tr>
<td class="org-left">.filterNotNull()</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">.map { &lt;Transformation&gt; }</td>
<td class="org-left">.joinToString { &lt;Transformation&gt; }</td>
</tr>

<tr>
<td class="org-left">.joinToString()</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">.filter { &lt;Predicate 1&gt; }</td>
<td class="org-left">.filter {</td>
</tr>

<tr>
<td class="org-left">.filter { &lt;Predicate 2&gt; }</td>
<td class="org-left">&lt;Predicate 1&gt; &amp;&amp; &lt;Predicate 2&gt; }</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">.filter { it is Type }</td>
<td class="org-left">.filterIsInstance&lt;Type&gt;()</td>
</tr>

<tr>
<td class="org-left">.map { it as Type }</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">.sortedBy { &lt;Key 2&gt; }</td>
<td class="org-left">.sortedWith(</td>
</tr>

<tr>
<td class="org-left">.sortedBy { &lt;Key 1&gt; }</td>
<td class="org-left">compareBy( { &lt;Key 1&gt; }, { &lt;Key 2&gt; }))</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">listOf(&#x2026;)</td>
<td class="org-left">listOfNotNull(&#x2026;)</td>
</tr>

<tr>
<td class="org-left">.filterNotNull()</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">.withIndex()</td>
<td class="org-left">.filterIndexed { index, elem -&gt;</td>
</tr>

<tr>
<td class="org-left">.filter { (index, elem) -&gt;</td>
<td class="org-left">&lt;Predicate using index&gt; }</td>
</tr>

<tr>
<td class="org-left">&lt;Predicate using index&gt; }</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">.map { it.value }</td>
<td class="org-left">(Similarly for map, forEach, reduce and fold)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orge838233" class="outline-4">
<h4 id="orge838233"><span class="section-number-4">4.2.2.</span> Item 51: Consider Arrays with primitives for performance-critical processing</h4>
<div class="outline-text-4" id="text-4-2-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Kotlin type</th>
<th scope="col" class="org-left">Java type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Int</td>
<td class="org-left">int</td>
</tr>

<tr>
<td class="org-left">List&lt;Int&gt;</td>
<td class="org-left">List&lt;Integer&gt;</td>
</tr>

<tr>
<td class="org-left">Array&lt;Int&gt;</td>
<td class="org-left">Integer[]</td>
</tr>

<tr>
<td class="org-left">IntArray</td>
<td class="org-left">int[]</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgc0c4c8e" class="outline-4">
<h4 id="orgc0c4c8e"><span class="section-number-4">4.2.3.</span> Item 52: Consider using mutable collections</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
In local scope we generally do not need the control over how they are changed, so mutable collections should be preferred. Especially in utils, where element insertion might happen many times.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class="links"><a href="#content">T</a><a href="index.html">H</a><a id="share-img">I</a><a href="20210629191000-000_index.html">0</a></div><script src="static/dom2img.min.js" type="text/javascript"></script><script src="static/x.js" type="text/javascript"></script>
</div>
</body>
</html>
